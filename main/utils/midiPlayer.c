#include "midiPlayer.h"

#include <string.h>

#include "waveTables.h"
#include "hdw-dac.h"
#include "fp_math.h"

//==============================================================================
// Generated by tools/midi_freqs.py
//==============================================================================
static const uq16_16 noteFreqTable[] = {
    0x00082d01, // C-2  = 8.176 Hz
    0x0008a976, // C#-2 = 8.662 Hz
    0x00092d51, // D-2  = 9.177 Hz
    0x0009b904, // D#-2 = 9.723 Hz
    0x000a4d05, // E-2  = 10.301 Hz
    0x000ae9d3, // F-2  = 10.913 Hz
    0x000b8ff5, // F#-2 = 11.562 Hz
    0x000c3ff7, // G-2  = 12.250 Hz
    0x000cfa70, // G#-2 = 12.978 Hz
    0x000dc000, // A-1  = 13.750 Hz
    0x000e914f, // A#-1 = 14.568 Hz
    0x000f6f11, // B-1  = 15.434 Hz
    0x00105a02, // C-1  = 16.352 Hz
    0x001152ec, // C#-1 = 17.324 Hz
    0x00125aa3, // D-1  = 18.354 Hz
    0x00137208, // D#-1 = 19.445 Hz
    0x00149a0a, // E-1  = 20.602 Hz
    0x0015d3a7, // F-1  = 21.827 Hz
    0x00171fe9, // F#-1 = 23.125 Hz
    0x00187fed, // G-1  = 24.500 Hz
    0x0019f4e0, // G#-1 = 25.957 Hz
    0x001b8000, // A0   = 27.500 Hz
    0x001d229f, // A#0  = 29.135 Hz
    0x001ede22, // B0   = 30.868 Hz
    0x0020b405, // C0   = 32.703 Hz
    0x0022a5d8, // C#0  = 34.648 Hz
    0x0024b546, // D0   = 36.708 Hz
    0x0026e410, // D#0  = 38.891 Hz
    0x00293415, // E0   = 41.203 Hz
    0x002ba74e, // F0   = 43.654 Hz
    0x002e3fd2, // F#0  = 46.249 Hz
    0x0030ffdb, // G0   = 48.999 Hz
    0x0033e9c0, // G#0  = 51.913 Hz
    0x00370000, // A1   = 55.000 Hz
    0x003a453e, // A#1  = 58.270 Hz
    0x003dbc44, // B1   = 61.735 Hz
    0x00416809, // C1   = 65.406 Hz
    0x00454bb0, // C#1  = 69.296 Hz
    0x00496a8c, // D1   = 73.416 Hz
    0x004dc821, // D#1  = 77.782 Hz
    0x0052682a, // E1   = 82.407 Hz
    0x00574e9b, // F1   = 87.307 Hz
    0x005c7fa5, // F#1  = 92.499 Hz
    0x0061ffb5, // G1   = 97.999 Hz
    0x0067d380, // G#1  = 103.826 Hz
    0x006e0000, // A2   = 110.000 Hz
    0x00748a7b, // A#2  = 116.541 Hz
    0x007b7888, // B2   = 123.471 Hz
    0x0082d013, // C2   = 130.813 Hz
    0x008a9760, // C#2  = 138.591 Hz
    0x0092d517, // D2   = 146.832 Hz
    0x009b9041, // D#2  = 155.563 Hz
    0x00a4d054, // E2   = 164.814 Hz
    0x00ae9d37, // F2   = 174.614 Hz
    0x00b8ff49, // F#2  = 184.997 Hz
    0x00c3ff6a, // G2   = 195.998 Hz
    0x00cfa700, // G#2  = 207.652 Hz
    0x00dc0000, // A3   = 220.000 Hz
    0x00e914f6, // A#3  = 233.082 Hz
    0x00f6f110, // B3   = 246.942 Hz
    0x0105a025, // C3   = 261.626 Hz
    0x01152ec1, // C#3  = 277.183 Hz
    0x0125aa2e, // D3   = 293.665 Hz
    0x01372082, // D#3  = 311.127 Hz
    0x0149a0a8, // E3   = 329.628 Hz
    0x015d3a6d, // F3   = 349.228 Hz
    0x0171fe92, // F#3  = 369.994 Hz
    0x0187fed5, // G3   = 391.995 Hz
    0x019f4e01, // G#3  = 415.305 Hz
    0x01b80000, // A4   = 440.000 Hz
    0x01d229ec, // A#4  = 466.164 Hz
    0x01ede220, // B4   = 493.883 Hz
    0x020b404a, // C4   = 523.251 Hz
    0x022a5d82, // C#4  = 554.365 Hz
    0x024b545c, // D4   = 587.330 Hz
    0x026e4104, // D#4  = 622.254 Hz
    0x0293414f, // E4   = 659.255 Hz
    0x02ba74db, // F4   = 698.456 Hz
    0x02e3fd25, // F#4  = 739.989 Hz
    0x030ffdaa, // G4   = 783.991 Hz
    0x033e9c01, // G#4  = 830.609 Hz
    0x03700000, // A5   = 880.000 Hz
    0x03a453d9, // A#5  = 932.328 Hz
    0x03dbc440, // B5   = 987.767 Hz
    0x04168094, // C5   = 1046.502 Hz
    0x0454bb04, // C#5  = 1108.731 Hz
    0x0496a8b9, // D5   = 1174.659 Hz
    0x04dc8208, // D#5  = 1244.508 Hz
    0x0526829e, // E5   = 1318.510 Hz
    0x0574e9b6, // F5   = 1396.913 Hz
    0x05c7fa4a, // F#5  = 1479.978 Hz
    0x061ffb54, // G5   = 1567.982 Hz
    0x067d3803, // G#5  = 1661.219 Hz
    0x06e00000, // A6   = 1760.000 Hz
    0x0748a7b1, // A#6  = 1864.655 Hz
    0x07b78880, // B6   = 1975.533 Hz
    0x082d0128, // C6   = 2093.005 Hz
    0x08a97607, // C#6  = 2217.461 Hz
    0x092d5172, // D6   = 2349.318 Hz
    0x09b90410, // D#6  = 2489.016 Hz
    0x0a4d053d, // E6   = 2637.020 Hz
    0x0ae9d36b, // F6   = 2793.826 Hz
    0x0b8ff494, // F#6  = 2959.955 Hz
    0x0c3ff6a7, // G6   = 3135.963 Hz
    0x0cfa7005, // G#6  = 3322.438 Hz
    0x0dc00000, // A7   = 3520.000 Hz
    0x0e914f62, // A#7  = 3729.310 Hz
    0x0f6f1100, // B7   = 3951.066 Hz
    0x105a0251, // C7   = 4186.009 Hz
    0x1152ec0e, // C#7  = 4434.922 Hz
    0x125aa2e4, // D7   = 4698.636 Hz
    0x13720820, // D#7  = 4978.032 Hz
    0x149a0a79, // E7   = 5274.041 Hz
    0x15d3a6d6, // F7   = 5587.652 Hz
    0x171fe928, // F#7  = 5919.911 Hz
    0x187fed4e, // G7   = 6271.927 Hz
    0x19f4e00b, // G#7  = 6644.875 Hz
    0x1b800000, // A8   = 7040.000 Hz
    0x1d229ec4, // A#8  = 7458.620 Hz
    0x1ede2200, // B8   = 7902.133 Hz
    0x20b404a2, // C8   = 8372.018 Hz
    0x22a5d81d, // C#8  = 8869.844 Hz
    0x24b545c7, // D8   = 9397.273 Hz
    0x26e41040, // D#8  = 9956.063 Hz
    0x293414f2, // E8   = 10548.082 Hz
    0x2ba74dac, // F8   = 11175.303 Hz
    0x2e3fd250, // F#8  = 11839.822 Hz
    0x30ffda9d, // G8   = 12543.854 Hz
};

// Multiply a frequency by this value to bend it by a number of cents
// uint32_t bentPitch = (uint32_t)(((uint64_t)pitch * bendTable[bendCents + 100]) >> 24)
static const uq24_8 bendTable[] = {
    0x00f1a1bf, // -100 cents => 0.94387
    0x00f1c57d, // -99 cents => 0.94442
    0x00f1e940, // -98 cents => 0.94497
    0x00f20d08, // -97 cents => 0.94551
    0x00f230d5, // -96 cents => 0.94606
    0x00f254a8, // -95 cents => 0.94660
    0x00f27880, // -94 cents => 0.94715
    0x00f29c5e, // -93 cents => 0.94770
    0x00f2c040, // -92 cents => 0.94825
    0x00f2e428, // -91 cents => 0.94879
    0x00f30816, // -90 cents => 0.94934
    0x00f32c08, // -89 cents => 0.94989
    0x00f35000, // -88 cents => 0.95044
    0x00f373fe, // -87 cents => 0.95099
    0x00f39800, // -86 cents => 0.95154
    0x00f3bc08, // -85 cents => 0.95209
    0x00f3e015, // -84 cents => 0.95264
    0x00f40428, // -83 cents => 0.95319
    0x00f42840, // -82 cents => 0.95374
    0x00f44c5d, // -81 cents => 0.95429
    0x00f47080, // -80 cents => 0.95484
    0x00f494a8, // -79 cents => 0.95539
    0x00f4b8d5, // -78 cents => 0.95595
    0x00f4dd08, // -77 cents => 0.95650
    0x00f50140, // -76 cents => 0.95705
    0x00f5257d, // -75 cents => 0.95760
    0x00f549c0, // -74 cents => 0.95816
    0x00f56e08, // -73 cents => 0.95871
    0x00f59255, // -72 cents => 0.95926
    0x00f5b6a8, // -71 cents => 0.95982
    0x00f5db00, // -70 cents => 0.96037
    0x00f5ff5e, // -69 cents => 0.96093
    0x00f623c1, // -68 cents => 0.96148
    0x00f64829, // -67 cents => 0.96204
    0x00f66c97, // -66 cents => 0.96259
    0x00f6910a, // -65 cents => 0.96315
    0x00f6b582, // -64 cents => 0.96371
    0x00f6da00, // -63 cents => 0.96426
    0x00f6fe84, // -62 cents => 0.96482
    0x00f7230c, // -61 cents => 0.96538
    0x00f7479a, // -60 cents => 0.96594
    0x00f76c2e, // -59 cents => 0.96649
    0x00f790c7, // -58 cents => 0.96705
    0x00f7b565, // -57 cents => 0.96761
    0x00f7da09, // -56 cents => 0.96817
    0x00f7feb2, // -55 cents => 0.96873
    0x00f82361, // -54 cents => 0.96929
    0x00f84815, // -53 cents => 0.96985
    0x00f86cce, // -52 cents => 0.97041
    0x00f8918d, // -51 cents => 0.97097
    0x00f8b651, // -50 cents => 0.97153
    0x00f8db1b, // -49 cents => 0.97209
    0x00f8ffea, // -48 cents => 0.97265
    0x00f924bf, // -47 cents => 0.97322
    0x00f94999, // -46 cents => 0.97378
    0x00f96e78, // -45 cents => 0.97434
    0x00f9935d, // -44 cents => 0.97490
    0x00f9b848, // -43 cents => 0.97547
    0x00f9dd38, // -42 cents => 0.97603
    0x00fa022d, // -41 cents => 0.97660
    0x00fa2728, // -40 cents => 0.97716
    0x00fa4c28, // -39 cents => 0.97772
    0x00fa712e, // -38 cents => 0.97829
    0x00fa9639, // -37 cents => 0.97885
    0x00fabb4a, // -36 cents => 0.97942
    0x00fae060, // -35 cents => 0.97999
    0x00fb057c, // -34 cents => 0.98055
    0x00fb2a9d, // -33 cents => 0.98112
    0x00fb4fc4, // -32 cents => 0.98169
    0x00fb74f0, // -31 cents => 0.98225
    0x00fb9a21, // -30 cents => 0.98282
    0x00fbbf59, // -29 cents => 0.98339
    0x00fbe495, // -28 cents => 0.98396
    0x00fc09d7, // -27 cents => 0.98453
    0x00fc2f1f, // -26 cents => 0.98509
    0x00fc546c, // -25 cents => 0.98566
    0x00fc79bf, // -24 cents => 0.98623
    0x00fc9f17, // -23 cents => 0.98680
    0x00fcc475, // -22 cents => 0.98737
    0x00fce9d8, // -21 cents => 0.98794
    0x00fd0f41, // -20 cents => 0.98851
    0x00fd34b0, // -19 cents => 0.98909
    0x00fd5a23, // -18 cents => 0.98966
    0x00fd7f9d, // -17 cents => 0.99023
    0x00fda51c, // -16 cents => 0.99080
    0x00fdcaa0, // -15 cents => 0.99137
    0x00fdf02a, // -14 cents => 0.99195
    0x00fe15ba, // -13 cents => 0.99252
    0x00fe3b4f, // -12 cents => 0.99309
    0x00fe60ea, // -11 cents => 0.99367
    0x00fe868a, // -10 cents => 0.99424
    0x00feac30, // -9 cents => 0.99481
    0x00fed1dc, // -8 cents => 0.99539
    0x00fef78d, // -7 cents => 0.99596
    0x00ff1d43, // -6 cents => 0.99654
    0x00ff42ff, // -5 cents => 0.99712
    0x00ff68c1, // -4 cents => 0.99769
    0x00ff8e88, // -3 cents => 0.99827
    0x00ffb455, // -2 cents => 0.99885
    0x00ffda28, // -1 cents => 0.99942
    0x01000000, // +0 cents => 1.00000
    0x010025de, // +1 cents => 1.00058
    0x01004bc1, // +2 cents => 1.00116
    0x010071aa, // +3 cents => 1.00173
    0x01009798, // +4 cents => 1.00231
    0x0100bd8d, // +5 cents => 1.00289
    0x0100e386, // +6 cents => 1.00347
    0x01010986, // +7 cents => 1.00405
    0x01012f8b, // +8 cents => 1.00463
    0x01015595, // +9 cents => 1.00521
    0x01017ba5, // +10 cents => 1.00579
    0x0101a1bb, // +11 cents => 1.00637
    0x0101c7d7, // +12 cents => 1.00696
    0x0101edf8, // +13 cents => 1.00754
    0x0102141f, // +14 cents => 1.00812
    0x01023a4b, // +15 cents => 1.00870
    0x0102607d, // +16 cents => 1.00928
    0x010286b5, // +17 cents => 1.00987
    0x0102acf2, // +18 cents => 1.01045
    0x0102d335, // +19 cents => 1.01104
    0x0102f97e, // +20 cents => 1.01162
    0x01031fcc, // +21 cents => 1.01220
    0x01034620, // +22 cents => 1.01279
    0x01036c7a, // +23 cents => 1.01337
    0x010392d9, // +24 cents => 1.01396
    0x0103b93e, // +25 cents => 1.01455
    0x0103dfa9, // +26 cents => 1.01513
    0x01040619, // +27 cents => 1.01572
    0x01042c8f, // +28 cents => 1.01630
    0x0104530b, // +29 cents => 1.01689
    0x0104798d, // +30 cents => 1.01748
    0x0104a014, // +31 cents => 1.01807
    0x0104c6a1, // +32 cents => 1.01866
    0x0104ed33, // +33 cents => 1.01924
    0x010513cb, // +34 cents => 1.01983
    0x01053a69, // +35 cents => 1.02042
    0x0105610d, // +36 cents => 1.02101
    0x010587b6, // +37 cents => 1.02160
    0x0105ae65, // +38 cents => 1.02219
    0x0105d51a, // +39 cents => 1.02278
    0x0105fbd5, // +40 cents => 1.02337
    0x01062295, // +41 cents => 1.02397
    0x0106495b, // +42 cents => 1.02456
    0x01067027, // +43 cents => 1.02515
    0x010696f8, // +44 cents => 1.02574
    0x0106bdd0, // +45 cents => 1.02633
    0x0106e4ad, // +46 cents => 1.02693
    0x01070b8f, // +47 cents => 1.02752
    0x01073278, // +48 cents => 1.02811
    0x01075966, // +49 cents => 1.02871
    0x0107805a, // +50 cents => 1.02930
    0x0107a754, // +51 cents => 1.02990
    0x0107ce53, // +52 cents => 1.03049
    0x0107f558, // +53 cents => 1.03109
    0x01081c64, // +54 cents => 1.03168
    0x01084374, // +55 cents => 1.03228
    0x01086a8b, // +56 cents => 1.03288
    0x010891a7, // +57 cents => 1.03347
    0x0108b8ca, // +58 cents => 1.03407
    0x0108dff1, // +59 cents => 1.03467
    0x0109071f, // +60 cents => 1.03526
    0x01092e53, // +61 cents => 1.03586
    0x0109558c, // +62 cents => 1.03646
    0x01097ccb, // +63 cents => 1.03706
    0x0109a410, // +64 cents => 1.03766
    0x0109cb5b, // +65 cents => 1.03826
    0x0109f2ac, // +66 cents => 1.03886
    0x010a1a02, // +67 cents => 1.03946
    0x010a415e, // +68 cents => 1.04006
    0x010a68c0, // +69 cents => 1.04066
    0x010a9028, // +70 cents => 1.04126
    0x010ab796, // +71 cents => 1.04186
    0x010adf09, // +72 cents => 1.04247
    0x010b0683, // +73 cents => 1.04307
    0x010b2e02, // +74 cents => 1.04367
    0x010b5587, // +75 cents => 1.04427
    0x010b7d12, // +76 cents => 1.04488
    0x010ba4a2, // +77 cents => 1.04548
    0x010bcc39, // +78 cents => 1.04608
    0x010bf3d5, // +79 cents => 1.04669
    0x010c1b78, // +80 cents => 1.04729
    0x010c4320, // +81 cents => 1.04790
    0x010c6ace, // +82 cents => 1.04850
    0x010c9282, // +83 cents => 1.04911
    0x010cba3c, // +84 cents => 1.04972
    0x010ce1fb, // +85 cents => 1.05032
    0x010d09c1, // +86 cents => 1.05093
    0x010d318c, // +87 cents => 1.05154
    0x010d595d, // +88 cents => 1.05214
    0x010d8135, // +89 cents => 1.05275
    0x010da912, // +90 cents => 1.05336
    0x010dd0f5, // +91 cents => 1.05397
    0x010df8dd, // +92 cents => 1.05458
    0x010e20cc, // +93 cents => 1.05519
    0x010e48c1, // +94 cents => 1.05580
    0x010e70bb, // +95 cents => 1.05641
    0x010e98bc, // +96 cents => 1.05702
    0x010ec0c2, // +97 cents => 1.05763
    0x010ee8cf, // +98 cents => 1.05824
    0x010f10e1, // +99 cents => 1.05885
    0x010f38f9, // +100 cents => 1.05946
};
//==============================================================================
// End generated code section
//==============================================================================

// For MIDI values with coarse and fine bytes, each 7 bits
#define UINT14_MAX (0x3FFF)

#define VS_ANY(statePtr) ((statePtr)->attack | (statePtr)->decay | (statePtr)->release | (statePtr)->sustain)
#define VS_RELEASABLE(statePtr) ((statePtr)->attack | (statePtr)->decay | (statePtr)->sustain)
#define VS_HOLDABLE(statePtr) VS_RELEASABLE(statePtr)
#define MS_TO_TICKS(ms) ((ms) * DAC_SAMPLE_RATE_HZ / 1000)

static uint32_t allocVoice(midiPlayer_t* player, voiceStates_t* states, uint8_t voiceCount);
static uq16_16 bendPitch(uint8_t noteId, uint16_t pitchWheel);
static void midiGmOn(midiPlayer_t* player);

static int8_t defaultDrumkitFunc(percussionNote_t drum, uint32_t idx, void* data);

static const midiTimbre_t defaultDrumkitTimbre = {
    .type = NOISE,
    .flags = TF_PERCUSSION,
    .percussion = {
        .playFunc = defaultDrumkitFunc,
        // TODO: Define the data and put it here!
        .data = NULL,
    },
    .envelope = { 0 },
    .name = "Swadge Drums 0",
};

static const midiTimbre_t acousticGrandPianoTimbre = {
    .type = WAVETABLE,
    .flags = TF_NONE,
    .waveIndex = 0,
    .envelope = {
        // TODO: Just realized I forgot how ADSR actually works halfway through writing everything else...
        // So go make sure the rest of everything makes sense, maybe rename everything to {a,d,r}Time and {s}Level for clarity
        // Pretty fast attack
        .attack = MS_TO_TICKS(24),
        // Take a good long while to reach the sustain level
        .decay = MS_TO_TICKS(750),
        // Sustain at about 75% of initial volume
        .sustain = 192,
        // And a not-too-short release time
        .release = MS_TO_TICKS(100),
        // Yup, I'm sure it will sound exactly like a grand piano now!
    },
    .name = "Acoustic Grand Piano",
};

// Check for the first unused note, then try to steal one in order of less to more bad, and return INT32_MAX if none are available
static uint32_t allocVoice(midiPlayer_t* player, voiceStates_t* states, uint8_t voiceCount)
{
#define CHECK_VOICE(val) ((val) ? (__builtin_ctz((val))) : 0)

    uint32_t allStates = VS_ANY(states) | states->held; //states->attack | states->decay | states->release | states->sustain | states->held;

    // Find the first voice index which is not used
    uint32_t firstFreeIdx = CHECK_VOICE(allStates);

    uint8_t step = 0;
    // Keep trying more things until we have a note index
    while (firstFreeIdx >= voiceCount)
    {
        uint32_t check;
        switch (step)
        {
            // TODO: does a note that's already in the release phase get affected by the hold pedal?
            // I'm going to say NO!
            case 0: check = states->release | states->held; break;
            case 1: check = states->sustain | states->held; break;
            case 2: check = states->decay | states->held; break;
            case 3: check = states->attack | states->held; break;
            // TODO: try not to steal the lowest or highest note
            // no note found sorry!
            case 4: return UINT32_MAX;
        }

        firstFreeIdx = CHECK_VOICE(check);
    }

    return firstFreeIdx;
#undef CHECK_VOICE
}

/**
 * @brief Calculate pitch bend
 *
 * @param noteId The MIDI note ID to bend
 * @param pitchWheel The 14-bit MIDI pitch wheel value
 * @return uint32_t The note frequency as a UQ16.16 value
 */
static uq16_16 bendPitch(uint8_t noteId, uint16_t pitchWheel)
{
    // Pitch wheel is centered, don't bother to change it at
    if (pitchWheel == 0x2000)
    {
        return noteFreqTable[noteId];
    }

    // First, convert the pitch wheel value to +/-cents
    int32_t bendCents = (((int16_t)-0x2000) + pitchWheel) * 100 / 0x1FFF;
    uint64_t freq = (noteFreqTable[noteId] * bendTable[bendCents + 100]) >> 24;
    return (uq16_16)freq;
}

/**
 * @brief Activate General MIDI mode for a MIDI player
 *
 * @param player The MIDI player to set to General MIDI mode
 */
static void midiGmOn(midiPlayer_t* player)
{
    bool percOscSetup = false;

    for (uint8_t chanIdx = 0; chanIdx < 16; chanIdx++)
    {
        midiChannel_t* chan = &player->channels[chanIdx];

        chan->volume = UINT14_MAX;
        chan->pitchBend = 0x2000;
        chan->program = 0;

        if (chanIdx == 10)
        {
            // Channel 10 is reserved for percussion.
            chan->percussion = true;

            // TODO: Should we just have a pointer instead? That will work great as long as we don't need to modify the timbre in-place (which MIDI does technically allow)
            memcpy(&chan->timbre, &defaultDrumkitTimbre, sizeof(midiTimbre_t));
        }
        else
        {
            chan->percussion = false;
            memcpy(&chan->timbre, &acousticGrandPianoTimbre, sizeof(midiTimbre_t));
        }

        midiVoice_t* voices = chan->percussion ? player->percVoices : chan->voices;
        uint8_t voiceCount = chan->percussion ? PERCUSSION_VOICES : VOICE_PER_CHANNEL;

        for (uint8_t voiceIdx = 0; voiceIdx < voiceCount; voiceIdx++)
        {
            midiVoice_t* voice = &voices[voiceIdx];

            for (uint8_t oscIdx = 0; oscIdx < OSC_PER_VOICE; oscIdx++)
            {
                switch (voice->timbre.type)
                {
                    case WAVETABLE:
                    {
                        swSynthInitOscillatorWave(&voice->oscillators[oscIdx], waveTableFunc, (void*)((uint32_t)(voice->timbre.waveIndex)), 0, 0);
                        // Make sure we don't count the percussion oscillators multiple times
                        if (!chan->percussion || !percOscSetup)
                        {
                            player->allOscillators[player->oscillatorCount++] = &voice->oscillators[oscIdx];
                        }
                        break;
                    }

                    case SAMPLE:
                    {
                        // TODO: Sample support
                        // player->allSamplers[player->samplerCount++] = ...
                        break;
                    }

                    case NOISE:
                    {
                        swSynthInitOscillator(&voice->oscillators[oscIdx], SHAPE_NOISE, 0, 0);

                        // Make sure we don't count the percussion oscillators multiple times
                        if (!chan->percussion || !percOscSetup)
                        {
                            player->allOscillators[player->oscillatorCount++] = &voice->oscillators[oscIdx];
                        }
                        break;
                    }
                }
            }

            if (chan->percussion)
            {
                // If this was a percussion channel, then all the percussion oscillators were set up
                percOscSetup = true;
            }
        }
    }
    if (player->oscillatorCount > 0)
    {
        player->oscillatorCount--;
    }
}

static int8_t defaultDrumkitFunc(percussionNote_t drum, uint32_t idx, void* data)
{
    switch (drum)
    {
        // TODO drumkit
        default:
        {
            static uint16_t shiftReg = 0xACE1u;

            /* taps: 16 14 13 11; feedback polynomial: x^16 + x^14 + x^13 + x^11 + 1 */
            uint16_t bit = ((shiftReg >> 0) ^ (shiftReg >> 2) ^ (shiftReg >> 3) ^ (shiftReg >> 5)) & 1u;
            shiftReg     = (shiftReg >> 1) | (bit << 15);

            /* This will return as an 8-bit signed value */
            return shiftReg;
        }
    }
}

void midiPlayerInit(midiPlayer_t* player)
{
    // Zero out EVERYTHING
    memset(player, 0, sizeof(midiPlayer_t));
    midiGmOn(player);
}

void midiPlayerFillBuffer(midiPlayer_t* player, uint8_t* samples, int16_t len)
{
    for (int16_t n = 0; n < len; n++)
    {
        int32_t sample = swSynthSumOscillators(player->allOscillators, player->oscillatorCount);
        // TODO: Sample support
        // sample += samplerSumSamplers(player->allSamplers, player->samplerCount)

        samples[n] = sample / (player->oscillatorCount /*+ player->samplerCount*/) + 128;
    }
}

void midiAllSoundOff(midiPlayer_t* player)
{
    // TODO: It is unclear whether this applies to every channel or just one
    // Seems like people "agree" it's special and applies to every channel
    // But also people say the spec is deficient in this area.
    // So if it's up to us, let's just do them all!

    for (int chanIdx = 0; chanIdx < 16; chanIdx++)
    {
        midiChannel_t* chan = &player->channels[chanIdx];
        // Here we don't bother to check whether this channel is using its own voices
        // or the percussion voices, since we want to turn them off no matter what.
        // This is because All Sounds Off is often used as a "panic" button to stop any
        // stuck notes. So just in case we get into a bad state where notes are playing
        // but we don't think they are, this will always stop them anyway.
        for (uint8_t voiceIdx = 0; voiceIdx < VOICE_PER_CHANNEL; voiceIdx++)
        {
            // TODO: Maybe move this all into a stopVoice() function
            // TODO: Remove envState?
            chan->voices[voiceIdx].envState = ES_STOPPED;
            chan->voices[voiceIdx].transitionTicks = 0;
            // TODO: Handle samplers
            for (uint8_t oscIdx = 0; oscIdx < OSC_PER_VOICE; oscIdx++)
            {
                swSynthSetVolume(&chan->voices[voiceIdx].oscillators[oscIdx], 0);
                swSynthSetFreqPrecise(&chan->voices[voiceIdx].oscillators[oscIdx], 0);
            }
        }
    }

    for (uint8_t voiceIdx = 0; voiceIdx < PERCUSSION_VOICES; voiceIdx++)
    {
        // TODO: Remove envState?
        player->percVoices[voiceIdx].envState = ES_STOPPED;
        player->percVoices[voiceIdx].transitionTicks = 0;
        // TODO: Handle samplers
        for (uint8_t oscIdx = 0; oscIdx < OSC_PER_VOICE; oscIdx++)
        {
            swSynthSetVolume(&player->percVoices[voiceIdx].oscillators[oscIdx], 0);
            swSynthSetFreqPrecise(&player->percVoices[voiceIdx].oscillators[oscIdx], 0);
        }
    }
}


void midiAllNotesOff(midiPlayer_t* player, uint8_t channel)
{
    midiChannel_t* chan = &player->channels[channel];
    voiceStates_t* states = chan->percussion ? &player->percVoiceStates : &chan->voiceStates;

    uint32_t playingVoices = VS_ANY(states) | states->held;
    while (playingVoices != 0)
    {
        // TODO / FIXME: This causes an additional search for the playing channel which is unnecessary
        // Instead, refactor the core of midiNoteOff() into an internal midiVoiceOff() function
        // That's probably a good idea anyway with how complicated midiNoteOff() is getting
        uint8_t voiceIdx = __builtin_ctz(playingVoices);
        midiNoteOff(player, channel, chan->voices[voiceIdx].note, 0x7F);
    }
}


void midiNoteOn(midiPlayer_t* player, uint8_t chanId, uint8_t note, uint8_t velocity)
{
    if (velocity == 0)
    {
        midiNoteOff(player, chanId, note, 0x7F);
        return;
    }

    midiChannel_t* chan = &player->channels[chanId];
    // Use the appropriate voice pool for the instrument type
    // Percussion gets its own
    voiceStates_t* states = chan->percussion ? &player->percVoiceStates : &chan->voiceStates;
    midiVoice_t* voices = chan->percussion ? player->percVoices : chan->voices;
    uint8_t voiceCount = chan->percussion ? PERCUSSION_VOICES : VOICE_PER_CHANNEL;
    uint32_t voiceIdx = (chan->timbre.flags & TF_MONO) ? 0 : allocVoice(player, states, voiceCount);

    if (voiceIdx >= voiceCount)
    {
        // no voices available and we couldn't find an appropriate one to steal
        // if this happens often we should just allocate more voices
        // (or make the stealing algorithm always succeed)
        return;
    }

    uint32_t voiceBit = (1 << voiceIdx);
    states->attack |= voiceBit;
    // TODO might remove `envMap`
    voices[voiceIdx].envState = ES_ATTACK;
    voices[voiceIdx].note = note;
    // TODO: Add a note -> voice map in the channel?

    switch (chan->timbre.type)
    {
        case WAVETABLE:
        case NOISE:
        {
            // TODO: velocity should attack time instead of directly affecting volume
            swSynthSetFreq(&voices[voiceIdx].oscillators[0], bendPitch(note, chan->pitchBend));
            swSynthSetVolume(&voices[voiceIdx].oscillators[0], velocity << 1);
            voices[voiceIdx].transitionTicks = chan->timbre.envelope.attack;
            break;
        }

        case SAMPLE:
        {
            // TODO: Sample support!
            break;
        }
    }
}


void midiNoteOff(midiPlayer_t* player, uint8_t channel, uint8_t note, uint8_t velocity)
{
    midiChannel_t* chan = &player->channels[channel];
    voiceStates_t* states = chan->percussion ? &player->percVoiceStates : &chan->voiceStates;
    midiVoice_t* voices = chan->percussion ? player->percVoices : chan->voices;

    // check the bitmaps to see if there's any note to release
    uint32_t playingVoices = VS_ANY(&chan->voiceStates);


    // Find the channel playing this note
    while (playingVoices != 0)
    {
        uint8_t voiceIdx = __builtin_ctz(playingVoices);
        if (voices[voiceIdx].note == note)
        {
            // This is the one!
            uint32_t voiceBit = (1 << voiceIdx);

            if (chan->held)
            {
                // This note should be held.
                // If the note is currently in its sustain state, put it in held instead
                // Otherwise, do nothing because if it's in release, it released before
                // the hold started; if it's in attack or decay the transition to hold
                // will happen elsewhere
                // TODO: This logic might be a bit clearer if we have an ON flag as well.
                // This would just track whether the note is explicitly set to on and would help
                // with things like
                if (chan->voiceStates.sustain & voiceBit)
                {
                    voices[voiceIdx].transitionTicks = UINT32_MAX;
                    states->attack &= ~voiceBit;
                    states->decay &= ~voiceBit;
                    states->sustain &= ~voiceBit;
                    states->attack &= ~voiceBit;
                    states->held |= voiceBit;
                }
            }
            else
            {
                voices[voiceIdx].transitionTicks = chan->timbre.envelope.release;

                //if (voices[voiceIdx].transitionTicks == 0)
                //{
                    //voices[voiceIdx].envState = ES_STOPPED;
                    for (uint8_t i = 0; i < OSC_PER_VOICE; i++)
                    {
                        swSynthSetVolume(&voices[voiceIdx].oscillators[i], 0);
                    }
                //}
                //else
                //{
                    //voices[voiceIdx].envState = ES_RELEASE;
                //}
            }

            // TODO: Probably need to check what state it's in first
            /*switch (voices[voiceIdx].envState)
            {
                case ES_STOPPED: break;
                case ES_ATTACK: break;
                case ES_DECAY: break;
                case ES_SUSTAIN: break;
                case ES_RELEASE: break; // no-op, note is already released
            }*/

            return;
        }

        // Move on to the next voice if
        playingVoices &= ~(1 << voiceIdx);
    }
}

void midiSetProgram(midiPlayer_t* player, uint8_t channel, uint8_t program)
{
    // TODO: Handle Set Program
    // TODO: If a channel is set to/unset from percussion make sure we update allOscillators
    player->channels[channel].program = program;

    midiChannel_t* chan = &player->channels[channel];
    midiVoice_t* voices = chan->percussion ? player->percVoices : chan->voices;
    uint8_t voiceCount = chan->percussion ? PERCUSSION_VOICES : VOICE_PER_CHANNEL;

    for (uint8_t voiceIdx = 0; voiceIdx < voiceCount; voiceIdx++)
    {
        midiVoice_t* voice = &voices[voiceIdx];

        for (uint8_t oscIdx = 0; oscIdx < OSC_PER_VOICE; oscIdx++)
        {
            swSynthSetVolume(&voice->oscillators[oscIdx], 0);
            swSynthSetWaveFunc(&voice->oscillators[oscIdx], waveTableFunc, (void*)((uint32_t)program));
        }
    }

}


void midiSustain(midiPlayer_t* player, uint8_t channel, uint8_t val)
{
    midiChannel_t* chan = &player->channels[channel];
    bool newHold = MIDI_TO_BOOL(val);

    if (chan->held != newHold)
    {
        voiceStates_t* voiceStates = chan->percussion ? &player->percVoiceStates : &chan->voiceStates;
        midiVoice_t* voices = chan->percussion ? player->percVoices : chan->voices;
        if (newHold)
        {
            // Hold is being activated
            // Set all channels that can be held (e.g. not already in release state)
            // TODO: Don't do this here -- we need to set this state only when a note
            // would otherwise be put into the release state
            //chan->voiceStates.held = VS_HOLDABLE(&chan->voiceStates);

            // Find the notes that we should start holding
            // DON'T put them in the hold state though!
            // We will handle that when the note is released.
            uint32_t notesToHold = voiceStates->sustain;

            while (notesToHold != 0)
            {
                uint8_t voiceIdx = __builtin_ctz(notesToHold);
                uint32_t voiceBit = (1 << voiceIdx);

                // If this voice is in the sustain state, tell it to stay there!
                if (voiceStates->sustain & voiceBit)
                {
                    // Postpone transition
                    voices[voiceIdx].transitionTicks = UINT32_MAX;
                }
            }
        }
        else
        {
            // Hold is being deactivated
            // Find all notes that are only on because of the hold flag
            // Put them in the release state
            // Set their transition time to the release time

            // TODO: make sure the rest of the hold implementation matches this?
            uint32_t notesToCancel = VS_HOLDABLE(voiceStates);
            voiceStates->held = VS_HOLDABLE(voiceStates);

            while (notesToCancel != 0)
            {
                uint8_t voiceIdx = __builtin_ctz(notesToCancel);
                uint32_t voiceBit = (1 << voiceIdx);

                if (voiceStates->sustain & voiceBit)
                {
                }

                // Clear that note from the bitmap and move on to the next
                notesToCancel &= ~voiceBit;
            }
        }
        chan->held = newHold;
    }
}


void midiControlChange(midiPlayer_t* player, uint8_t channel, uint8_t control, uint8_t val)
{
    midiAllNotesOff(player, channel);
    // TODO maybe some sort of resetChannel() function?
    // also
}


void midiPitchWheel(midiPlayer_t* player, uint8_t channel, uint16_t value)
{
    // Save the pitch bend value
    player->channels[channel].pitchBend = value;

    // Find all the voices currently sounding and update their frequencies
    uint32_t playingVoices = VS_ANY(&player->channels[channel].voiceStates) | player->channels[channel].voiceStates.held;
    while (playingVoices != 0)
    {
        uint8_t voiceIdx = __builtin_ctz(playingVoices);
        uint32_t voiceBit = (1 << voiceIdx);

        for (uint8_t oscIdx = 0; oscIdx < OSC_PER_VOICE; oscIdx++)
        {
            // Apply the pitch bend to all this channel's oscillators
            // TODO: If each voice has multiple oscillators, we would obviously
            // want to be able to control them separately here.
            // Maybe we only apply that for like, chorus?
            swSynthSetFreqPrecise(
                &player->channels[channel].voices[voiceIdx].oscillators[oscIdx],
                bendPitch(player->channels[channel].voices[voiceIdx].note, value));
        }

        // Next!
        playingVoices &= ~voiceBit;
    }
}
