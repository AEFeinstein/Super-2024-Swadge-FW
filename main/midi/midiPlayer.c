#include "midiPlayer.h"

#include <string.h>
#include <inttypes.h>

#include "waveTables.h"
#include "midiNoteFreqs.h"
#include "midiData.h"
#include "midiUtil.h"
#include "hdw-dac.h"
#include "fp_math.h"
#include "esp_log.h"
#include "drums.h"
#include "macros.h"

#define OSC_DITHER

//==============================================================================
// Generated by tools/midi/freqs.py
//==============================================================================
#ifdef OSC_DITHER
// Apply a random offset to each oscillator to maybe make it less likely for waves to "stack" exactly
static const uint8_t oscDither[] = {
    139, 227, 5,   103, 241, 67, 251, 109, 197, 59,  61,  3,   53,  229, 127, 23,  73,  223,
    13,  19,  47,  7,   181, 37, 2,   239, 29,  113, 167, 131, 41,  151, 83,  137, 11,  193,
    107, 17,  191, 43,  101, 71, 233, 179, 97,  79,  31,  211, 163, 157, 89,  199, 149, 173,
};
#endif
//==============================================================================
// End generated code section
//==============================================================================

// For MIDI values with coarse and fine bytes, each 7 bits
#define UINT14_MAX (0x3FFF)

/// @brief Convert the sample count to MIDI ticks
#define SAMPLES_TO_MIDI_TICKS(n, tempo, div) ((n) * 1000000 * (div) / DAC_SAMPLE_RATE_HZ / (tempo))

/// @brief Convert a number of MIDI ticks to the offset of the first sample of the
#define TICKS_TO_SAMPLES(ticks, tempo, div) ((ticks) * DAC_SAMPLE_RATE_HZ / (1000000) * (tempo) / (div))

#define VS_ANY(statePtr) ((statePtr)->on)

#define VOICE_CUR_VOL(voice) ((uint8_t)CLAMP(((voice)->transitionStartVol + ((int)(voice)->targetVol - (int)(voice)->transitionStartVol) * ((int)(voice)->transitionTicksTotal - (int)(voice)->transitionTicks) / (int)(voice)->transitionTicksTotal), 0, 255))

// Values for the percussion special states bitmap
#define SHIFT_HI_HAT   (0)
#define SHIFT_WHISTLE  (6)
#define SHIFT_GUIRO    (12)
#define SHIFT_CUICA    (18)
#define SHIFT_TRIANGLE (24)

#define MASK_HI_HAT   (0x3F)
#define MASK_WHISTLE  (0x3F << SHIFT_WHISTLE)
#define MASK_GUIRO    (0x3F << SHIFT_GUIRO)
#define MASK_CUICA    (0x3F << SHIFT_CUICA)
#define MASK_TRIANGLE (0x3F << SHIFT_TRIANGLE)

// Represents that no voice has been allocated to the instrument, within the special states bitmap
#define VOICE_FREE (0x3F)

static bool globalPlayerInit                          = false;
static midiPlayer_t globalPlayers[NUM_GLOBAL_PLAYERS] = {0};

static uint32_t allocVoice(const voiceStates_t* states, uint8_t voiceCount);
static bool releaseNote(voiceStates_t* states, uint8_t voiceIdx, midiVoice_t* voice);
static void midiStepVoice(midiChannel_t* channel, voiceStates_t* states, uint8_t voiceIdx, midiVoice_t* voice);
static void setVoiceTimbre(midiVoice_t* voice, midiTimbre_t* timbre);
static const midiTimbre_t* getTimbreForProgram(bool percussion, uint8_t bank, uint8_t program);
static void midiGmOn(midiPlayer_t* player);
static int32_t midiSumPercussion(midiPlayer_t* player);
static void handleMidiEvent(midiPlayer_t* player, const midiStatusEvent_t* event);
static void handleSysexEvent(midiPlayer_t* player, const midiSysexEvent_t* sysex);
static void handleMetaEvent(midiPlayer_t* player, const midiMetaEvent_t* event);
static void handleEvent(midiPlayer_t* player, const midiEvent_t* event);
static void midiSongEnd(midiPlayer_t* player);

// Check for the first unused note, then try to steal one in order of less to more bad, and return INT32_MAX if none are
// available
/**
 * @brief Return the index of an unallocated voice from the given voice pool.
 *
 * This function finds the voice index to allocate, but the caller is responsible for updating the state
 * bitmaps to actuallymark it as allocated.
 * If there are no unallocated voices remaining, an allocated voice index may be returned.
 *
 * @param states A pointer to the voice state bitmaps for this pool
 * @param voiceCount The number of voices in this pool
 * @return uint32_t The index of the voice to allocate
 */
static uint32_t allocVoice(const voiceStates_t* states, uint8_t voiceCount)
{
    uint32_t allStates
        = VS_ANY(states)
          | states->held | states->attack | states->decay | states->release | states->sustain | states->sustenuto;

    // Set up a bitflag which has a 1 set for every voice that is NOT being used
    //                         /- flip the bits so a 1 represents an unused voice and a 0 represents an in-use voice
    //                        /                /- mask the bits to only go up to the number of voices we have
    //                       v                v
    uint32_t unusedVoices = (~allStates) & (0xFFFFFFFFu >> (32 - voiceCount));

    if (unusedVoices != 0)
    {
        // Return whatever the first voice that's not allocated is
        return __builtin_ctz(unusedVoices);
    }
    else
    {
        // No unused voices!
        // Try a different approach, treat notes in release state as not in use to hopefully steal one of those
        allStates &= ~states->release;
        unusedVoices = (~allStates) & (0xFFFFFFFFu >> (32 - voiceCount));
        if (unusedVoices != 0)
        {
            return __builtin_ctz(unusedVoices);
        }

        // Gotta steal a note, so steal the first one
        return 0;
    }
}

/**
 * @brief Release a note and transition it to the release state if it has one
 *
 * @param states The voice state bitmap
 * @param voiceIdx The index of this voice in the bitmap
 * @param voice A pointer to the actual voice which is used to determine the transition
 * @return true if the note should be deallocated
 * @return false if the note is still playing and should remain allocated
 */
static bool releaseNote(voiceStates_t* states, uint8_t voiceIdx, midiVoice_t* voice)
{
    uint32_t voiceBit = 1 << voiceIdx;
    uint32_t mask = UINT32_MAX & ~voiceBit;

    // Unconditionally unset the voice for all states
    states->on &= mask;
    states->attack &= mask;
    states->decay &= mask;
    states->sustain &= mask;

    uint8_t oscVol = 0;

    uint32_t releaseTime = voice->timbre->envelope.releaseTime + ((voice->timbre->envelope.releaseTimeVel * (int8_t)voice->velocity) >> 16);

    // We don't care what state the note is in, as long as it's not already in the release state
    if ((0 == (states->release & voiceBit)) && releaseTime)
    {
        // Release time will take some
        states->release |= voiceBit;
        voice->transitionStartVol = VOICE_CUR_VOL(voice);
        voice->transitionTicksTotal = voice->transitionTicks = releaseTime;
        voice->targetVol = 0;

        // Calculate the rate at which the volume will adjust based on the state transition length
        oscVol = voice->transitionStartVol; //VOICE_CUR_VOL(voice);

    }
    else if (releaseTime)
    {
        // Already in release... ok, just get the current volume then
        oscVol = VOICE_CUR_VOL(voice);
    }
    else
    {
        // No release time, just end it immediately
        oscVol = 0;
        voice->transitionTicksTotal = voice->transitionTicks = UINT32_MAX;
        voice->targetVol = 0;
    }

    for (uint8_t i = 0; i < OSC_PER_VOICE; i++)
    {
        swSynthSetVolume(&voice->oscillators[i], oscVol);

        // add up the actual current oscillator volume
    }

    if (0 == oscVol)
    {
        // If there's no volume on any oscillator, then the note is done playing
        states->release &= mask;
        return true;
    }

    return false;
}

void midiStepVoice(midiChannel_t* channels, voiceStates_t* states, uint8_t voiceIdx, midiVoice_t* voice)
{
    uint32_t voiceBit = 1 << voiceIdx;
    uint32_t pressureVol = voice->velocity << 1 | 1;

    if (voice->transitionTicks != UINT32_MAX)
    {
        while (!voice->transitionTicks)
        {
            uint32_t sustainVol = CLAMP(voice->timbre->envelope.sustainVol + ((voice->timbre->envelope.sustainVolVel * (int8_t)voice->velocity) >> 16), 0, 255);

            if (states->attack & voiceBit)
            {
                // Current state: ATTACK --> DECAY
                states->attack &= ~voiceBit;
                states->decay |= voiceBit;

                uint32_t decayTime = voice->timbre->envelope.decayTime + ((voice->timbre->envelope.attackTimeVel * (int8_t)voice->velocity) >> 16);

                if (voice->transitionTicksTotal)
                {
                    // Attack time is > 0
                    voice->transitionStartVol = VOICE_CUR_VOL(voice);
                }
                else
                {
                    // Attack time == 0, so we go straight to the attack target
                    voice->transitionStartVol = voice->targetVol;
                }

                voice->transitionTicksTotal = voice->transitionTicks = decayTime;
                voice->targetVol = (uint8_t)(sustainVol & 0xFF);
            }
            else if (states->decay & voiceBit)
            {
                states->decay &= ~voiceBit;

                pressureVol = sustainVol;

                // Ok so we're going from DECAY to SUSTAIN, sustain lasts forever
                // BUT - we only go to sustain IF the note is still ON (via key on, hold, or sustenuto)
                // Otherwise, we skip straight to release
                if ((voiceBit & (states->on | states->held | states->sustenuto)))
                {
                    // Go to sustain
                    states->sustain |= voiceBit;

                    // Sustain lasts forever! As long as the note is on/held/sustenuto'd
                    //voice->transitionTicksTotal = voice->transitionTicks = UINT32_MAX;
                    if (voice->transitionTicksTotal)
                    {
                        voice->transitionStartVol = VOICE_CUR_VOL(voice);
                    }
                    else
                    {
                        voice->transitionStartVol = voice->targetVol;
                    }

                    voice->targetVol = (uint8_t)(sustainVol & 0xFF);
                    voice->transitionTicksTotal = UINT32_MAX;
                    voice->transitionTicks = UINT32_MAX;

                    // No need to set the transition times or volume, it was done already

                    // Break because the loop doesn't check for UINT32_MAX, just 0
                    break;
                }
                else
                {
                    // Go to release!
                    states->release |= voiceBit;

                    // Calculate how long the release fadeout will take
                    uint32_t releaseTime = voice->timbre->envelope.releaseTime + ((voice->timbre->envelope.releaseTimeVel * (int8_t)voice->velocity) >> 16);

                    // Save the start volume to current volume and the target to 0
                    if (voice->transitionTicksTotal)
                    {
                        voice->transitionStartVol = VOICE_CUR_VOL(voice);
                    }
                    else
                    {
                        voice->transitionStartVol = voice->targetVol;
                    }

                    voice->targetVol = 0;

                    // Set the transition length accordingly
                    voice->transitionTicksTotal = voice->transitionTicks = releaseTime;

                }
            }
            else if (states->release & voiceBit)
            {
                // Transition from RELEASE to OFF
                states->release &= ~voiceBit;
                states->on &= ~voiceBit;
                channels[voice->channel].allocedVoices &= ~voiceBit;

                pressureVol = 0;
                voice->transitionStartVol = VOICE_CUR_VOL(voice);
                voice->targetVol = 0;

                voice->transitionTicksTotal = UINT32_MAX;
                voice->transitionTicks = UINT32_MAX;
                // Note's done, don't need to check again
                break;
            }
        }

        voice->transitionTicks--;
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////

    // By defualt, use the pressure volume for the oscillator
    uint8_t oscVol = pressureVol;

    // TODO: I think the logic here might cause something worse:TM: than clipping?

    // Make sure we're in a transitionable state and wouldn't do a divide-by-zero to interpolate the target volume
    if (voice->transitionTicksTotal != UINT32_MAX)
    {
        // Calculate the rate at which the volume will adjust based on the state transition length
        oscVol = VOICE_CUR_VOL(voice);
    }

    for (int i = 0; i < OSC_PER_VOICE; i++)
    {
        swSynthSetVolume(&voice->oscillators[i], oscVol);
    }
}

/**
 * @brief Set the timbre (instrument definition) of a MIDI voice
 *
 * @param voice The voice to set the timbre for
 * @param timbre A pointer to the MIDI timbre
 */
static void setVoiceTimbre(midiVoice_t* voice, midiTimbre_t* timbre)
{
    voice->timbre = timbre;
    for (uint8_t oscIdx = 0; oscIdx < OSC_PER_VOICE; oscIdx++)
    {
        switch (timbre->type)
        {
            case WAVETABLE:
            {
                swSynthSetWaveFunc(&voice->oscillators[oscIdx], timbre->waveFunc, (void*)((uintptr_t)timbre->waveIndex));
                voice->oscillators[oscIdx].chorus = timbre->effects.chorus;
                break;
            }

            case NOISE:
            {
                swSynthSetShape(&voice->oscillators[oscIdx], SHAPE_NOISE);
                break;
            }

            case WAVE_SHAPE:
            {
                swSynthSetShape(&voice->oscillators[oscIdx], timbre->shape);
                break;
            }

            case SAMPLE:
            {
                // TODO: Sample support!
                break;
            }
        }
    }
}

/**
 * @brief Return a pointer to the base timbre for the given bank and program definition
 *
 * @param bank The bank to select the instrument from, from 0 to 127 with 0 being the GM instruments
 * @param program The program number, from 0 to 127
 * @return const midiTimbre_t*
 */
static const midiTimbre_t* getTimbreForProgram(bool percussion, uint8_t bank, uint8_t program)
{
    if (percussion)
    {
        switch (bank)
        {
            case 1:
                return &donutDrumkitTimbre;

            case 0:
            default:
                return &defaultDrumkitTimbre;
        }
    }
    else
    {
        switch (bank)
        {
            case 1:
            {
                if (program < magfestTimbreCount)
                {
                    return magfestTimbres[program];
                }

                return &magfestWaveTimbre;
            }

            case 0:
            default:
                return &acousticGrandPianoTimbre;
        }
    }
}

/**
 * @brief Activate General MIDI mode for a MIDI player
 *
 * @param player The MIDI player to set to General MIDI mode
 */
static void midiGmOn(midiPlayer_t* player)
{
    for (uint8_t chanIdx = 0; chanIdx < MIDI_CHANNEL_COUNT; chanIdx++)
    {
        midiChannel_t* chan = &player->channels[chanIdx];

        chan->volume    = UINT14_MAX;
        chan->pitchBend = PITCH_BEND_CENTER;
        chan->program   = 0;

        // Channel 10 (index 9) is reserved for percussion.
        chan->percussion = (9 == chanIdx);

        memcpy(&chan->timbre, getTimbreForProgram(chan->percussion, 0, chan->program), sizeof(midiTimbre_t));
    }
}

/**
 * @brief Step each playing percussion note forward by one sample and return the raw sum
 *
 * @param player The MIDI player to sum percussion notes for
 * @return int32_t The unsigned 32-bit sample, without any headroom or clipping applied
 */
static int32_t midiSumPercussion(midiPlayer_t* player)
{
    voiceStates_t* states = &player->percVoiceStates;
    midiVoice_t* voices   = player->percVoices;

    int32_t sum = 0;

    // Ignore the 'held' flag, this is percussion!
    uint32_t playingVoices = states->on;
    while (playingVoices != 0)
    {
        uint8_t voiceIdx = __builtin_ctz(playingVoices);
        playingVoices &= ~(1 << voiceIdx);

        bool done = false;
        sum += voices[voiceIdx].timbre->percussion.playFunc(voices[voiceIdx].note, voices[voiceIdx].sampleTick++, &done,
                                                            voices[voiceIdx].percScratch,
                                                            voices[voiceIdx].timbre->percussion.data);

        if (done)
        {
            switch (voices[voiceIdx].note)
            {
                case CLOSED_HI_HAT:
                case PEDAL_HI_HAT:
                case OPEN_HI_HAT:
                {
                    player->percSpecialStates |= VOICE_FREE << SHIFT_HI_HAT;
                    break;
                }

                case SHORT_WHISTLE:
                case LONG_WHISTLE:
                {
                    player->percSpecialStates |= VOICE_FREE << SHIFT_WHISTLE;
                    break;
                }

                case SHORT_GUIRO:
                case LONG_GUIRO:
                {
                    player->percSpecialStates |= VOICE_FREE << SHIFT_GUIRO;
                    break;
                }

                case MUTE_CUICA:
                case OPEN_CUICA:
                {
                    player->percSpecialStates |= VOICE_FREE << SHIFT_CUICA;
                    break;
                }

                case MUTE_TRIANGLE:
                case OPEN_TRIANGLE:
                {
                    player->percSpecialStates |= VOICE_FREE << SHIFT_TRIANGLE;
                    break;
                }

                default:
                    break;
            }

            states->on &= ~(1 << voiceIdx);
            voices[voiceIdx].sampleTick = 0;
            memset(voices[voiceIdx].percScratch, 0, 4 * sizeof(uint32_t));
        }
    }

    return sum;
}

/**
 * @brief Process a normal MIDI status event and update the player state accordingly
 *
 * @param player The MIDI player to handle the event
 * @param event The MIDI status event to handle
 */
static void handleMidiEvent(midiPlayer_t* player, const midiStatusEvent_t* event)
{
    if (event->status & 0x80)
    {
        // Normal status message
        uint8_t channel = event->status & 0x0F;
        uint8_t cmd     = (event->status >> 4) & 0x0F;

        if (player->channels[channel].ignore)
        {
            return;
        }

        switch (cmd)
        {
            // Note OFF
            case 0x8:
            {
                uint8_t midiKey  = event->data[0];
                uint8_t velocity = event->data[1];
                midiNoteOff(player, channel, midiKey, velocity);
                break;
            }

            // Note ON
            case 0x9:
            {
                uint8_t midiKey  = event->data[0];
                uint8_t velocity = event->data[1];
                midiNoteOn(player, channel, midiKey, velocity);
                break;
            }

            // AfterTouch
            case 0xA:
            {
                uint8_t midiKey  = event->data[0];
                uint8_t velocity = event->data[1];
                midiAfterTouch(player, channel, midiKey, velocity);
                break;
            }

            // Control change
            case 0xB:
            {
                uint8_t controlId  = event->data[0];
                uint8_t controlVal = event->data[1];
                midiControlChange(player, channel, controlId, controlVal);
                break;
            }

            // Program Select
            case 0xC:
            {
                uint8_t program = event->data[0];
                midiSetProgram(player, channel, program);
                break;
            }

            // Channel Pressure
            case 0xD:
                // Maybe we don't need to implement this actually? Sounds like it's more of a keyboard event
                //player->channels[channel]. = 127;
                break;

            // Pitch bend
            case 0xE:
            {
                uint16_t range = ((event->data[1] & 0x7F) << 7) | (event->data[0] & 0x7F);
                midiPitchWheel(player, channel, range);
                break;
            }

            default:
                break;
        }
    }
    else if (event->status & 0xF0)
    {
        // System Message
    }
}

/**
 * @brief Process a non-MIDI meta-event from a file and update the player state accordingly
 *
 * @param player The MIDI player to handle the event
 * @param event The non-MIDI meta-event to handle
 */
static void handleMetaEvent(midiPlayer_t* player, const midiMetaEvent_t* event)
{
    switch (event->type)
    {
        case SEQUENCE_NUMBER:
            break;

        // Text events
        case TEXT:
        case COPYRIGHT:
        case SEQUENCE_OR_TRACK_NAME:
        case INSTRUMENT_NAME:
        case LYRIC:
        case MARKER:
        case CUE_POINT:
        {
            // Handle text, if the callback is set
            if (player->textMessageCallback)
            {
                player->textMessageCallback(event->type, event->text, event->length);
            }
            break;
        }

        // Obsolete
        case CHANNEL_PREFIX:
            break;
        case PORT_PREFIX:
            break;

        case END_OF_TRACK:
        {
            // TODO: Maybe detect if a track ends without including END_OF_TRACK and
            // synthesize one from the parser, just in case a file is malformed?
            if (player->reader.file->format == MIDI_FORMAT_2)
            {
                player->sampleCount = 0;
            }
            break;
        }

        case TEMPO:
        {
            midiSetTempo(player, event->tempo);
            break;
        }

        case SMPTE_OFFSET:
        {
            // TODO: Tempo support?
            break;
        }

        // These are informational only, we won't do anything with them here.
        case TIME_SIGNATURE:
            break;
        case KEY_SIGNATURE:
            break;

        // None supported
        case PROPRIETARY:
            break;
    }
}

/**
 * @brief Process a MIDI System-Exclusive event and update the player state accordingly
 *
 * @warning Not yet implemented
 *
 * @param player The MIDI player to handle the event
 * @param event The MIDI SysEx event to handle
 */
static void handleSysexEvent(midiPlayer_t* player, const midiSysexEvent_t* sysex)
{
    // TODO: Support SysEx commands - find some RGB ones we can yoink
    // Actually we can assign a non-registered control to R, G, and B
    // I think there's enough for every LED too assuming there's still like, 7 or so
    // AND: if possible have a sysex command (hmm) that sets all the LEDs to individual values at once
}

/**
 * @brief Process MIDI event of any type and update the player state accordingly
 *
 * @param player The MIDI player to handle the event
 * @param event The MIDI event to handle
 */
static void handleEvent(midiPlayer_t* player, const midiEvent_t* event)
{
    switch (event->type)
    {
        case MIDI_EVENT:
        {
            handleMidiEvent(player, &event->midi);
            break;
        }

        case META_EVENT:
        {
            handleMetaEvent(player, &event->meta);
            break;
        }

        case SYSEX_EVENT:
        {
            handleSysexEvent(player, &event->sysex);
            break;
        }
    }
}

static void midiSongEnd(midiPlayer_t* player)
{
    for (uint8_t ch = 0; ch < MIDI_CHANNEL_COUNT; ch++)
    {
        midiAllNotesOff(player, 0);
    }

    if (player->loop && player->mode == MIDI_FILE && player->reader.file)
    {
        resetMidiParser(&player->reader);
        player->sampleCount = 0;
        player->paused = false;
    }
    else
    {
        player->paused = true;
    }

    if (player->songFinishedCallback)
    {
        player->songFinishedCallback();
    }
}

void midiPlayerInit(midiPlayer_t* player)
{
    // Zero out EVERYTHING
    memset(player, 0, sizeof(midiPlayer_t));

    // Initialize the oscillators and count them
    for (int voiceIdx = 0; voiceIdx < POOL_VOICE_COUNT + PERCUSSION_VOICES; voiceIdx++)
    {
        bool percussion = voiceIdx >= POOL_VOICE_COUNT;
        midiVoice_t* voice
            = percussion ? (&player->percVoices[voiceIdx - POOL_VOICE_COUNT]) : (&player->poolVoices[voiceIdx]);
        for (uint8_t oscIdx = 0; oscIdx < OSC_PER_VOICE; oscIdx++)
        {
            swSynthInitOscillatorWave(&voice->oscillators[oscIdx], waveTableFunc, (void*)((uint32_t)0), 0, 0);
#ifdef OSC_DITHER
            voice->oscillators[oscIdx].accumulator.bytes[3]
                = (oscDither[player->oscillatorCount % ARRAY_SIZE(oscDither)]) & 0xFF;
#endif
            player->allOscillators[player->oscillatorCount++] = &voice->oscillators[oscIdx];
        }

        voice->timbre = percussion ? &defaultDrumkitTimbre : &acousticGrandPianoTimbre;
    }

    // Set up the values which must be non-zero
    midiPlayerReset(player);
}

void midiPlayerReset(midiPlayer_t* player)
{
    midiAllSoundOff(player);
    midiGmOn(player);

    // We need the tempo to not be zero, so set it to the default of 120BPM until we get a tempo event
    // 120 BPM == 500,000 microseconds per quarter note
    player->tempo = 500000;

    // Set all the relevant bits to 1, meaning not in use
    player->percSpecialStates = 0b00111111111111111111111111111111; // 0x4fffffff

    player->sampleCount    = 0;
    player->clipped        = 0;
    player->eventAvailable = false;
    player->volume         = UINT14_MAX;
    player->headroom       = MIDI_DEF_HEADROOM;

    deinitMidiParser(&player->reader);
    player->paused = true;
}

int32_t midiPlayerStep(midiPlayer_t* player)
{
    if (player->paused)
    {
        return 0;
    }

    bool checkEvents = false;
    if (player->mode == MIDI_FILE)
    {
        if (!player->eventAvailable)
        {
            player->eventAvailable = midiNextEvent(&player->reader, &player->pendingEvent);
        }

        if (player->eventAvailable)
        {
            if (player->pendingEvent.absTime
                <= SAMPLES_TO_MIDI_TICKS(player->sampleCount, player->tempo, player->reader.division))
            {
                checkEvents = true;
            }
        }
        else
        {
            ESP_LOGI("MIDI", "Done playing file!");
            midiSongEnd(player);
        }

        // Use a while loop since we may need to handle multiple events at the exact same time
        while (checkEvents
               && player->pendingEvent.absTime
                      <= SAMPLES_TO_MIDI_TICKS(player->sampleCount, player->tempo, player->reader.division))
        {
            // It's time, so handle the event now
            handleEvent(player, &player->pendingEvent);

            // Try and grab the next event, and if we got one, keep checking
            player->eventAvailable = midiNextEvent(&player->reader, &player->pendingEvent);
            checkEvents            = player->eventAvailable;
        }
    }
    else if (player->mode == MIDI_STREAMING)
    {
        if (player->streamingCallback)
        {
            while (player->streamingCallback(&player->pendingEvent))
            {
                handleEvent(player, &player->pendingEvent);
            }
        }
    }

    // Handle ADSR transitions, etc. for all voices
    uint32_t activeVoices = player->poolVoiceStates.on | player->poolVoiceStates.held | player->poolVoiceStates.sustenuto; //player->poolVoiceStates.attack | player->poolVoiceStates.decay | player->poolVoiceStates.sustain | player->poolVoiceStates.release;
    while (0 != activeVoices)
    {
        uint8_t voiceIdx = __builtin_ctz(activeVoices);
        midiStepVoice(player->channels, &player->poolVoiceStates, voiceIdx, &player->poolVoices[voiceIdx]);
        activeVoices &= ~(1 << voiceIdx);
    }

    // TODO: Sample support
    // sample += samplerSumSamplers(player->allSamplers, player->samplerCount)
    int32_t sample = swSynthSumOscillators(player->allOscillators, player->oscillatorCount);
    sample += midiSumPercussion(player);

    player->sampleCount++;

    // Apply the global volume value
    sample *= player->volume;
    sample /= UINT14_MAX;

    return sample;
}

void midiPlayerFillBuffer(midiPlayer_t* player, uint8_t* samples, int16_t len)
{
    if (player->seeking)
    {
        memset(samples, 128, len);
        return;
    }

    for (int16_t n = 0; n < len; n++)
    {
        // Step the state forward by one sample and return the next sample sum
        int32_t sample = midiPlayerStep(player);

        // Multiply the sample by 0.3 to provide some headroom for stacking samples
        sample *= player->headroom;
        sample >>= 16;

        if (sample < -128)
        {
            samples[n] = 0;
            player->clipped++;
        }
        else if (sample > 127)
        {
            samples[n] = 255;
            player->clipped++;
        }
        else
        {
            samples[n] = sample + 128;
        }
    }
}

void midiPlayerFillBufferMulti(midiPlayer_t* players, uint8_t playerCount, uint8_t* samples, int16_t len)
{
    for (int16_t n = 0; n < len; n++)
    {
        int32_t sample = 0;
        for (int i = 0; i < playerCount; i++)
        {
            if (players[i].seeking)
            {
                continue;
            }

            // Apply the player's headroom to its sample sum
            sample += (midiPlayerStep(&players[i]) * players[i].headroom);
        }

        // Shift right by 16 to account for the headroom application
        sample >>= 16;

        // TODO: Can't keep track of clipping here... does it matter?
        if (sample < -128)
        {
            samples[n] = 0;
        }
        else if (sample > 127)
        {
            samples[n] = 255;
        }
        else
        {
            samples[n] = sample + 128;
        }
    }
}

void midiAllSoundOff(midiPlayer_t* player)
{
    // TODO: It is unclear whether this applies to every channel or just one
    // Seems like people "agree" it's special and applies to every channel
    // But also people say the spec is deficient in this area.
    // So if it's up to us, let's just do them all!

    for (uint8_t voiceIdx = 0; voiceIdx < POOL_VOICE_COUNT; voiceIdx++)
    {
        // Here we don't bother to check whether each voice is being used, since we want
        // to turn them off no matter what. This is because All Sounds Off is often used
        // as a "panic" button to stop any stuck notes. So, just in case we get in a bad
        // state where notes are playing but we don't "think" they are, this will always
        // stop them anyway.
        // TODO: Maybe move this all into a stopVoice() function
        player->poolVoices[voiceIdx].transitionTicks = 0;
        player->poolVoices[voiceIdx].targetVol       = 0;
        player->poolVoiceStates.held                 = 0;
        player->poolVoiceStates.sustenuto            = 0;
        player->poolVoiceStates.attack               = 0;
        player->poolVoiceStates.decay                = 0;
        player->poolVoiceStates.sustain              = 0;
        player->poolVoiceStates.release              = 0;
        player->poolVoiceStates.on                   = 0;
        // TODO: Handle samplers
        for (uint8_t oscIdx = 0; oscIdx < OSC_PER_VOICE; oscIdx++)
        {
            swSynthSetVolume(&player->poolVoices[voiceIdx].oscillators[oscIdx], 0);
            swSynthSetFreqPrecise(&player->poolVoices[voiceIdx].oscillators[oscIdx], 0);
        }
    }

    for (uint8_t voiceIdx = 0; voiceIdx < PERCUSSION_VOICES; voiceIdx++)
    {
        player->percVoices[voiceIdx].transitionTicks = 0;
        player->percVoices[voiceIdx].targetVol       = 0;
        player->percVoiceStates.held                 = 0;
        player->percVoiceStates.on                   = 0;
        for (uint8_t oscIdx = 0; oscIdx < OSC_PER_VOICE; oscIdx++)
        {
            player->percVoices[voiceIdx].targetVol = 0;
            swSynthSetVolume(&player->percVoices[voiceIdx].oscillators[oscIdx], 0);
            swSynthSetFreqPrecise(&player->percVoices[voiceIdx].oscillators[oscIdx], 0);
        }
    }

    for (int chanIdx = 0; chanIdx < MIDI_CHANNEL_COUNT; chanIdx++)
    {
        midiChannel_t* chan = &player->channels[chanIdx];
        chan->allocedVoices = 0;
        chan->held          = false;
    }
}

void midiResetChannelControllers(midiPlayer_t* player, uint8_t channel)
{
    midiChannel_t* chan   = &player->channels[channel];
    midiSustain(player, channel, MIDI_FALSE);
    chan->volume = UINT14_MAX;
    chan->pitchBend = PITCH_BEND_CENTER;
    memcpy(&chan->timbre, getTimbreForProgram(chan->percussion, chan->bank, chan->program), sizeof(midiTimbre_t));
}

void midiAllNotesOff(midiPlayer_t* player, uint8_t channel)
{
    midiChannel_t* chan   = &player->channels[channel];
    voiceStates_t* states = chan->percussion ? &player->percVoiceStates : &player->poolVoiceStates;

    uint32_t playingVoices = VS_ANY(states) | states->held;
    while (playingVoices != 0)
    {
        // TODO / FIXME: This causes an additional search for the playing channel which is unnecessary
        // Instead, refactor the core of midiNoteOff() into an internal midiVoiceOff() function
        // That's probably a good idea anyway with how complicated midiNoteOff() is getting
        uint8_t voiceIdx = __builtin_ctz(playingVoices);
        midiNoteOff(player, channel, player->poolVoices[voiceIdx].note, 0x7F);

        playingVoices &= ~(1 << voiceIdx);
    }
}

void midiNoteOn(midiPlayer_t* player, uint8_t chanId, uint8_t note, uint8_t velocity)
{
    if (velocity == 0)
    {
        // MIDI note on with a value of 0 is considered a note off
        midiNoteOff(player, chanId, note, 0x7F);
        return;
    }

    midiChannel_t* chan = &player->channels[chanId];
    // Use the appropriate voice pool for the instrument type
    // Percussion gets its own
    voiceStates_t* states = chan->percussion ? &player->percVoiceStates : &player->poolVoiceStates;
    midiVoice_t* voices   = chan->percussion ? player->percVoices : player->poolVoices;
    uint8_t voiceCount    = chan->percussion ? PERCUSSION_VOICES : POOL_VOICE_COUNT;
    uint32_t voiceIdx     = allocVoice(states, voiceCount);

    if (chan->timbre.flags & TF_MONO)
    {
        if (chan->allocedVoices)
        {
            voiceIdx = chan->allocedVoices;
        }
    }

    if (chan->percussion)
    {
        // handle special cases for percussion instruments
        // this will check if a mutually exclusive note is already playing on a voice and cut it off with the new one
        switch (note)
        {
            case CLOSED_HI_HAT:
            case PEDAL_HI_HAT:
            case OPEN_HI_HAT:
            {
                uint8_t hiHatVoice = player->percSpecialStates & MASK_HI_HAT;
                if (hiHatVoice != VOICE_FREE)
                {
                    voiceIdx = hiHatVoice;
                }
                else
                {
                    player->percSpecialStates = (player->percSpecialStates & ~MASK_HI_HAT) | (voiceIdx << SHIFT_HI_HAT);
                }
                break;
            }

            case SHORT_WHISTLE:
            case LONG_WHISTLE:
            {
                uint8_t whistleVoice = (player->percSpecialStates & MASK_WHISTLE) >> SHIFT_WHISTLE;
                if (whistleVoice != VOICE_FREE)
                {
                    voiceIdx = whistleVoice;
                }
                else
                {
                    player->percSpecialStates
                        = (player->percSpecialStates & ~MASK_WHISTLE) | (voiceIdx << SHIFT_WHISTLE);
                }
                break;
            }

            case SHORT_GUIRO:
            case LONG_GUIRO:
            {
                uint8_t guiroVoice = (player->percSpecialStates & MASK_GUIRO) >> SHIFT_GUIRO;
                if (guiroVoice != VOICE_FREE)
                {
                    voiceIdx = guiroVoice;
                }
                else
                {
                    player->percSpecialStates = (player->percSpecialStates & ~MASK_GUIRO) | (voiceIdx << SHIFT_GUIRO);
                }
                break;
            }

            case MUTE_CUICA:
            case OPEN_CUICA:
            {
                uint8_t cuicaVoice = (player->percSpecialStates & MASK_CUICA) >> SHIFT_CUICA;
                if (cuicaVoice != VOICE_FREE)
                {
                    voiceIdx = cuicaVoice;
                }
                else
                {
                    player->percSpecialStates = (player->percSpecialStates & ~MASK_CUICA) | (voiceIdx << SHIFT_CUICA);
                }
                break;
            }

            case MUTE_TRIANGLE:
            case OPEN_TRIANGLE:
            {
                uint8_t triangleVoice = (player->percSpecialStates & MASK_TRIANGLE) >> SHIFT_TRIANGLE;
                if (triangleVoice != VOICE_FREE)
                {
                    voiceIdx = triangleVoice;
                }
                else
                {
                    player->percSpecialStates
                        = (player->percSpecialStates & ~MASK_TRIANGLE) | (voiceIdx << SHIFT_TRIANGLE);
                }
                break;
            }

            default:
                break;
        }

        // Handle the rest of the percussion notes normally, or handle the case where there was no conflict
    }

    if (voiceIdx >= voiceCount)
    {
        // no voices available and we couldn't find an appropriate one to steal
        // if this happens often we should just allocate more voices
        // (or make the stealing algorithm always succeed)
        return;
    }

    uint32_t voiceBit = (1 << voiceIdx);

    bool stolen = 0 != (voiceBit & (states->on | states->held));

    // Not good -- we need to figure out who was using this voice before, and clear it
    // This is necessary to fix stuck notes, but doesn't take care of everything
    if (stolen)
    {
        // TODO add a voice->channel map and get rid of this loop
        for (int i = 0; i < 16; i++)
        {
            if (player->channels[i].percussion == chan->percussion && (player->channels[i].allocedVoices & voiceBit))
            {
                player->channels[i].allocedVoices &= ~voiceBit;
                // Unnecessary but I'll keep it here for clarity, and the compiler can get rid of it
                states->on &= ~voiceBit;
                states->held &= ~voiceBit;
                states->sustenuto &= ~voiceBit;
                states->attack &= ~voiceBit;
                states->decay &= ~voiceBit;
                states->sustain &= ~voiceBit;
                states->release &= ~voiceBit;
                break;
            }
        }
    }

    midiVoice_t* voice = &voices[voiceIdx];

    chan->allocedVoices |= voiceBit;
    states->on |= voiceBit;
    voice->note = note;
    voice->channel = chanId;
    voice->velocity = velocity;

    // TODO: Add a note -> voice map in the channel?

    // Ensure the selected voice will play with the right instrument
    setVoiceTimbre(voice, &chan->timbre);

    if (chan->timbre.flags & TF_PERCUSSION)
    {
        // Reset the percussion voice state
        voice->sampleTick = 0;
    }
    else
    {
        // The volume based on the note velocity, used for the attack volume
        uint8_t pressureVol          = velocity << 1 | 1;
        // The volume to be used after the decay stage while the key is pressed or held
        uint32_t sustainVol = CLAMP(chan->timbre.envelope.sustainVol + ((chan->timbre.envelope.sustainVolVel * (int8_t)velocity) >> 16), 0, 255);

        uint32_t attackTime = chan->timbre.envelope.attackTime + ((chan->timbre.envelope.attackTimeVel * (int8_t)velocity) >> 16);

        voice->transitionTicks = voice->transitionTicksTotal = attackTime;
        states->attack |= voiceBit;
        voice->transitionStartVol = 0;
        voice->targetVol = pressureVol;

        // StepVoice() will take care of everything else

        // By default, use the pressure volume for the oscillator
        /*uint8_t oscVol = sustainVol;

        uint32_t attackTime = chan->timbre.envelope.attackTime + ((chan->timbre.envelope.attackTimeVel * (int8_t)velocity) >> 16);
        if (attackTime)
        {
            // We need to go into attack state
            states->attack |= voiceBit;
            voice->transitionTicksTotal = voice->transitionTicks = attackTime;
            voice->transitionStartVol = voice->targetVol;
            voice->targetVol = pressureVol;
        }
        else
        {
            // No time in attack, so go directly to decay
            uint32_t decayTime = chan->timbre.envelope.decayTime + ((chan->timbre.envelope.attackTimeVel * (int8_t)velocity) >> 16);
            if (decayTime)
            {
                states->decay |= voiceBit;
                voice->transitionTicksTotal = voice->transitionTicks = decayTime;
                voice->transitionStartVol = voice->targetVol;
                voice->targetVol = sustainVol;
            }
            else
            {
                if (sustainVol)
                {
                    states->sustain |= voiceBit;
                    voice->transitionTicksTotal = UINT32_MAX;
                    voice->transitionTicks = UINT32_MAX;

                    pressureVol = (uint8_t)(sustainVol & 0x7F);
                    voice->targetVol = pressureVol;
                }
                else
                {
                    uint32_t releaseTime = chan->timbre.envelope.releaseTime + ((chan->timbre.envelope.releaseTimeVel * (int8_t)velocity) >> 16);

                    if (releaseTime)
                    {
                        states->release |= voiceBit;
                        voice->transitionTicksTotal = voice->transitionTicks = releaseTime;
                        voice->transitionStartVol = voice->targetVol;
                        voice->targetVol = 0;
                    }
                    else
                    {
                        // Note is already over, do note off...
                        voice->targetVol = 0;
                        voice->transitionTicksTotal = voice->transitionTicks = UINT32_MAX;
                    }
                }
            }
        }

        // Make sure we're in a transitionable state and wouldn't do a divide-by-zero to interpolate the target volume
        if (voice->transitionTicksTotal != UINT32_MAX)
        {
            // Calculate the rate at which the volume will adjust based on the state transition length
            oscVol = VOICE_CUR_VOL(voice);// voice->transitionStartVol + (voice->targetVol - voice->transitionStartVol) * (voice->transitionTicksTotal - voice->transitionTicks) / voice->transitionTicksTotal;
        }
        else
        {
            oscVol = (uint8_t)(sustainVol & 0xFF);
        }*/

        swSynthSetVolume(&voice->oscillators[0], 0);
        swSynthSetFreqPrecise(&voice->oscillators[0], bendPitchWheel(note, chan->pitchBend));
    }
}

void midiAfterTouch(midiPlayer_t* player, uint8_t channel, uint8_t note, uint8_t velocity)
{
    midiChannel_t* chan   = &player->channels[channel];

    if (chan->percussion)
    {
        // I don't believe in percussion aftertouch
        return;
    }

    voiceStates_t* states = &player->poolVoiceStates;
    midiVoice_t* voices   = player->poolVoices;

   uint32_t playingVoices = VS_ANY(states) & chan->allocedVoices;

    // Find the channel playing this note
    while (playingVoices != 0)
    {
        uint8_t voiceIdx  = __builtin_ctz(playingVoices);
        uint32_t voiceBit = (1 << voiceIdx);
        midiVoice_t* voice = &voices[voiceIdx];

        if (voices[voiceIdx].note == note)
        {
            uint8_t pressureVol = velocity << 1 | 1;
            // This is the one we want!
            voice->velocity = velocity;

            uint32_t sustainVol = voice->timbre->envelope.sustainVol + ((voice->timbre->envelope.sustainVolVel * (int8_t)voice->velocity) >> 16);

            if (states->attack & voiceBit)
            {
                // Attack state, set using pressure velocity
                voice->targetVol = pressureVol;
            }
            else if ((states->decay | states->sustain) & voiceBit)
            {
                //  Decay or sustain state, set using new sustain velocity
                voice->targetVol = sustainVol;
            }

            return;
        }

        // Move on to the next voice
        playingVoices &= ~voiceBit;
    }
}

void midiNoteOff(midiPlayer_t* player, uint8_t channel, uint8_t note, uint8_t velocity)
{
    midiChannel_t* chan   = &player->channels[channel];
    voiceStates_t* states = chan->percussion ? &player->percVoiceStates : &player->poolVoiceStates;
    midiVoice_t* voices   = chan->percussion ? player->percVoices : player->poolVoices;

    // check the bitmaps to see if there's any note to release
    uint32_t playingVoices = VS_ANY(states) & chan->allocedVoices;

    // Find the channel playing this note
    while (playingVoices != 0)
    {
        uint8_t voiceIdx  = __builtin_ctz(playingVoices);
        uint32_t voiceBit = (1 << voiceIdx);

        if (voices[voiceIdx].note == note)
        {
            // This is the one we want!

            // Unset the on-ness of this note
            states->on &= ~voiceBit;
            if (chan->held)
            {
                states->held |= voiceBit;
            }
            else if (!chan->sustenuto || 0 == (states->sustenuto & voiceBit))
            {
                if (releaseNote(states, voiceIdx, &voices[voiceIdx]))
                {
                    // Do not deallocate the voice until it actually finishes playing
                    chan->allocedVoices &= ~voiceBit;
                }
            }

            return;
        }

        // Move on to the next voice
        playingVoices &= ~voiceBit;
    }
}

void midiSetProgram(midiPlayer_t* player, uint8_t channel, uint8_t program)
{
    // Dynamic voice allocation somehow makes this way simpler
    player->channels[channel].program = program;

    memcpy(&player->channels[channel].timbre, getTimbreForProgram(player->channels[channel].percussion, player->channels[channel].bank, program), sizeof(midiTimbre_t));

    // TODO: Actually define all the timbres individually instead of editing them like this
    // TODO: Remove hardcoded bank == 0 check
    if (player->channels[channel].timbre.type == WAVETABLE && player->channels[channel].bank == 0)
    {
        // It's fine for now because envelopes, etc. aren't fully implemented so the only difference is the wave index
        player->channels[channel].timbre.waveIndex = program;
    }
}

void midiSustain(midiPlayer_t* player, uint8_t channel, uint8_t val)
{
    midiChannel_t* chan = &player->channels[channel];
    bool newIsHold      = MIDI_TO_BOOL(val);

    if (chan->held != newIsHold)
    {
        voiceStates_t* voiceStates = chan->percussion ? &player->percVoiceStates : &player->poolVoiceStates;
        midiVoice_t* voices        = chan->percussion ? player->percVoices : player->poolVoices;
        if (newIsHold)
        {
            // Just set the held state for all the currently on notes.
            voiceStates->held |= chan->allocedVoices & voiceStates->on;
        }
        else
        {
            // for now what we do is just, if the note is held and not on, turn it off
            // if the note is on, just unset held
            // We should cancel all the notes which are not currently being held
            uint32_t notesToCancel = chan->allocedVoices & voiceStates->held & ~(voiceStates->on);

            // unset the hold flag for all
            // TODO: Isn't this going to always be 0?
            uint32_t newHold = (voiceStates->held & ~notesToCancel);

            // TODO Don't do it like this! Use releaseNote()

            while (notesToCancel != 0)
            {
                uint8_t voiceIdx  = __builtin_ctz(notesToCancel);
                uint32_t voiceBit = (1 << voiceIdx);

                // unset the note's bit and move on to the next one
                notesToCancel &= ~voiceBit;

                if (releaseNote(voiceStates, voiceIdx, &voices[voiceIdx]))
                {
                    chan->allocedVoices &= ~voiceBit;
                }
            }

            voiceStates->held = newHold;
        }
        chan->held = newIsHold;
    }
}

void midiSustenuto(midiPlayer_t* player, uint8_t channel, uint8_t val)
{
    midiChannel_t* chan = &player->channels[channel];
    bool newIsSust      = MIDI_TO_BOOL(val);

    if (chan->sustenuto != newIsSust)
    {
        voiceStates_t* voiceStates = chan->percussion ? &player->percVoiceStates : &player->poolVoiceStates;
        midiVoice_t* voices        = chan->percussion ? player->percVoices : player->poolVoices;

        if (newIsSust)
        {
            // Just set the sustenuto state for all the currently on notes.
            voiceStates->sustenuto |= (voiceStates->on & chan->allocedVoices);
        }
        else
        {
            // If the note is in the sustenuto state and the note is not held on by the key or sustain pedal,
            // then we cancel it.
            uint32_t notesToCancel = chan->allocedVoices & voiceStates->sustenuto & ~(voiceStates->on | voiceStates->held);

            // Unset all the sustenuto bits
            voiceStates->sustenuto &= ~chan->allocedVoices;

            while (notesToCancel != 0)
            {
                uint8_t voiceIdx  = __builtin_ctz(notesToCancel);
                uint32_t voiceBit = (1 << voiceIdx);

                if (releaseNote(voiceStates, voiceIdx, &voices[voiceIdx]))
                {
                    chan->allocedVoices &= ~voiceBit;
                }

                // unset the note's bit and move on to the next one
                notesToCancel &= ~voiceBit;
            }
        }
        chan->sustenuto = newIsSust;
    }
}

void midiControlChange(midiPlayer_t* player, uint8_t channel, uint8_t control, uint8_t val)
{
    // MIDI spec says control changes stop the channel
    // TODO: Implement some controls
    // TODO maybe some sort of resetChannel() function?
    switch (control)
    {
        // Sustain (64)
        case 0x40:
        {
            midiSustain(player, channel, val);
            break;
        }

        // Sustenuto (66)
        case 0x42:
        {
            midiSustenuto(player, channel, val);
            break;
        }

        // Sound Release Time (72)
        case 0x48:
        {
            player->channels[channel].timbre.envelope.releaseTime = MS_TO_SAMPLES(10 * val);
            break;
        }

        // Sound Attack Time (73)
        case 0x49:
        {
            player->channels[channel].timbre.envelope.attackTime = MS_TO_SAMPLES(10 * val);
            break;
        }

        // Chorus Level (93)
        case 0x5D:
        {
            // Set chorus (within reason, up to 16... which is kinda ridiculous anyway)
            player->channels[channel].timbre.effects.chorus = MIN(val, 16);
            break;
        }

        // All sounds off (120)
        case 0x78:
        {
            midiAllSoundOff(player);
            break;
        }

        // All controllers off (121)
        case 0x79:
        {
            midiResetChannelControllers(player, channel);
            break;
        }

        // All notes off (123)
        case 0x7B:
        {
            midiAllNotesOff(player, channel);
            break;
        }

        default:
            break;
    }
}

void midiPitchWheel(midiPlayer_t* player, uint8_t channel, uint16_t value)
{
    // Save the pitch bend value
    player->channels[channel].pitchBend = value;
    voiceStates_t* states = player->channels[channel].percussion ? &player->percVoiceStates : &player->poolVoiceStates;
    midiVoice_t* voices   = player->channels[channel].percussion ? player->percVoices : player->poolVoices;

    // Find all the voices currently sounding for this channel and update their frequencies
    uint32_t playingVoices = (VS_ANY(states) | states->held) & player->channels[channel].allocedVoices;

    while (playingVoices != 0)
    {
        uint8_t voiceIdx  = __builtin_ctz(playingVoices);
        uint32_t voiceBit = (1 << voiceIdx);

        for (uint8_t oscIdx = 0; oscIdx < OSC_PER_VOICE; oscIdx++)
        {
            // Apply the pitch bend to all this channel's oscillators
            // TODO: If each voice has multiple oscillators, we would obviously
            // want to be able to control them separately here.
            // Maybe we only apply that for like, chorus?
            swSynthSetFreqPrecise(&voices[voiceIdx].oscillators[oscIdx], bendPitchWheel(voices[voiceIdx].note, value));
        }

        // Next!
        playingVoices &= ~voiceBit;
    }
}

void midiSetTempo(midiPlayer_t* player, uint32_t tempo)
{
    uint32_t oldTempo = player->tempo;

    player->tempo       = tempo;
    player->sampleCount = player->sampleCount * tempo / oldTempo;
}

void midiSetFile(midiPlayer_t* player, const midiFile_t* song)
{
    player->mode = MIDI_FILE;
    if (player->reader.states == NULL)
    {
        initMidiParser(&player->reader, song);
    }
    else if (song == NULL)
    {
        deinitMidiParser(&player->reader);
        player->mode   = MIDI_STREAMING;
        player->paused = true;
    }
    else
    {
        midiParserSetFile(&player->reader, song);
    }
}

void midiPause(midiPlayer_t* player, bool pause)
{
    player->paused = pause;
}

void midiSeek(midiPlayer_t* player, uint32_t ticks)
{
    bool paused = player->paused;
    bool stopped = false;

    if (player->mode == MIDI_FILE && player->reader.file)
    {
        const midiFile_t* loadedFile = player->reader.file;
        midiTextCallback_t textCb = player->textMessageCallback;
        songFinishedCbFn endCb = player->songFinishedCallback;
        player->textMessageCallback = NULL;
        player->songFinishedCallback = NULL;
        bool loop = player->loop;

        if (SAMPLES_TO_MIDI_TICKS(player->sampleCount, player->tempo, player->reader.division) > ticks)
        {
            // We have to go back
            midiPlayerReset(player);
            midiSetFile(player, loadedFile);
        }

        // Set the seeking flag so that the DAC won't get any output
        player->seeking = true;

        // Unpause the player otherwise nothing will happen
        midiPause(player, false);
        player->loop = false;

        // Okay, new strategy:
        // We work in ticks here to preserve precision
        // Calculate the current tick, use that to skip through events
        // Once the tick is up-to-date, update the sample count
        // Done!

        ESP_LOGD("MIDI", "Seeking to %" PRIu32 "\n", ticks);

        uint32_t curTick = SAMPLES_TO_MIDI_TICKS(player->sampleCount, player->tempo, player->reader.division);
        ESP_LOGD("MIDI", "Current tick is %" PRIu32 "\n", curTick);

        while (curTick < ticks)
        {
            if (!player->eventAvailable)
            {
                player->eventAvailable = midiNextEvent(&player->reader, &player->pendingEvent);
            }

            if (!player->eventAvailable || player->pendingEvent.absTime > ticks)
            {
                ESP_LOGD("MIDI", "No more events between start and end time\n");
                curTick = ticks;
                break;
            }

            curTick = player->pendingEvent.absTime;
            ESP_LOGD("MIDI", "Next event is at tick %" PRIu32 "\n", curTick);
            player->sampleCount = TICKS_TO_SAMPLES(curTick, player->tempo, player->reader.division);
            handleEvent(player, &player->pendingEvent);
            player->eventAvailable = midiNextEvent(&player->reader, &player->pendingEvent);
        }

        player->sampleCount = TICKS_TO_SAMPLES(curTick, player->tempo, player->reader.division);

        stopped = !player->eventAvailable && !(player->eventAvailable = midiNextEvent(&player->reader, &player->pendingEvent));
        if (stopped)
        {
            midiSongEnd(player);

            if (endCb)
            {
                endCb();
            }
        }

        player->songFinishedCallback = endCb;
        player->textMessageCallback = textCb;
        player->loop = loop;
        player->seeking = false;
    }

    midiPause(player, paused || stopped);
}

//==============================================================================
// System-wide MIDI player functions
//==============================================================================

void initGlobalMidiPlayer(void)
{
    if (!globalPlayerInit)
    {
        globalPlayerInit = true;
        for (int i = 0; i < NUM_GLOBAL_PLAYERS; i++)
        {
            midiPlayerInit(&globalPlayers[i]);
        }
    }
}

void deinitGlobalMidiPlayer(void)
{
    if (globalPlayerInit)
    {
        for (int i = 0; i < NUM_GLOBAL_PLAYERS; i++)
        {
            midiPause(&globalPlayers[i], true);
            midiAllSoundOff(&globalPlayers[i]);
            midiPlayerReset(&globalPlayers[i]);
        }

        globalPlayerInit = false;
    }
}

void globalMidiPlayerFillBuffer(uint8_t* samples, int16_t len)
{
    if (globalPlayerInit)
    {
        midiPlayerFillBufferMulti(globalPlayers, NUM_GLOBAL_PLAYERS, samples, len);
    }
    else
    {
        memset(samples, 128, len);
    }
}

void globalMidiPlayerPlaySong(midiFile_t* song, uint8_t songIdx)
{
    initGlobalMidiPlayer();

    midiPause(&globalPlayers[songIdx], true);
    globalPlayers[songIdx].sampleCount = 0;
    midiSetFile(&globalPlayers[songIdx], song);
    midiPause(&globalPlayers[songIdx], false);
}

void globalMidiPlayerPlaySongCb(midiFile_t* song, uint8_t songIdx, songFinishedCbFn cb)
{
    globalMidiPlayerPlaySong(song, songIdx);
    globalPlayers[songIdx].songFinishedCallback = cb;
}

void globalMidiPlayerSetVolume(uint8_t trackType, int32_t volumeSetting)
{
    midiPlayer_t* player = &globalPlayers[trackType];

    if (volumeSetting <= 0)
    {
        player->volume = 0;
    }
    else if (volumeSetting >= 13)
    {
        player->volume = UINT14_MAX;
    }
    else
    {
        player->volume = (1 << (volumeSetting - 1));
    }
}

void globalMidiPlayerPauseAll(void)
{
    for (int i = 0; i < NUM_GLOBAL_PLAYERS; i++)
    {
        midiPause(&globalPlayers[i], true);
    }
}

void globalMidiPlayerResumeAll(void)
{
    for (int i = 0; i < NUM_GLOBAL_PLAYERS; i++)
    {
        midiPause(&globalPlayers[i], false);
    }
}

void globalMidiPlayerStop(bool reset)
{
    for (int i = 0; i < NUM_GLOBAL_PLAYERS; i++)
    {
        midiPause(&globalPlayers[i], true);

        if (reset)
        {
            midiPlayerReset(&globalPlayers[i]);
        }
        // TODO: implement seek
        // midiSeek(&globalPlayers[i], 0);
    }
}

midiPlayer_t* globalMidiPlayerGet(uint8_t songIdx)
{
    return &globalPlayers[songIdx];
}
