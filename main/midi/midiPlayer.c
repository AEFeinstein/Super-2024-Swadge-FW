#include "midiPlayer.h"

#include <string.h>
#include <inttypes.h>
#include <esp_heap_caps.h>

#include "waveTables.h"
#include "midiNoteFreqs.h"
#include "midiData.h"
#include "midiUtil.h"
#include "hdw-dac.h"
#include "fp_math.h"
#include "esp_log.h"
#include "drums.h"
#include "macros.h"
#include "cnfs.h"

// Uncomment to enable logging SysEx commands in detail
// #define DEBUG_SYSEX 1

#define OSC_DITHER

//==============================================================================
// Generated by tools/midi/freqs.py
//==============================================================================
#ifdef OSC_DITHER
// Apply a random offset to each oscillator to maybe make it less likely for waves to "stack" exactly
static const uint8_t oscDither[] = {
    139, 227, 5,   103, 241, 67, 251, 109, 197, 59,  61,  3,   53,  229, 127, 23,  73,  223,
    13,  19,  47,  7,   181, 37, 2,   239, 29,  113, 167, 131, 41,  151, 83,  137, 11,  193,
    107, 17,  191, 43,  101, 71, 233, 179, 97,  79,  31,  211, 163, 157, 89,  199, 149, 173,
};
#endif
//==============================================================================
// End generated code section
//==============================================================================

// For MIDI values with coarse and fine bytes, each 7 bits
#define UINT14_MAX (0x3FFF)

/// @brief Convert the sample count to MIDI ticks
#define SAMPLES_TO_MIDI_TICKS(n, tempo, div) ((n) * 1000000 * (div) / DAC_SAMPLE_RATE_HZ / (tempo))

/// @brief Convert a number of MIDI ticks to the offset of the first sample of the
#define TICKS_TO_SAMPLES(ticks, tempo, div) ((ticks) * DAC_SAMPLE_RATE_HZ / (1000000) * (tempo) / (div))

#define VS_ANY(statePtr) ((statePtr)->on)

#define VOICE_CUR_VOL(voice)                                                                     \
    (/*(uint8_t)*/ ((voice)->transitionStartVol                                                  \
                    + ((int)(voice)->targetVol - (int)(voice)->transitionStartVol)               \
                          * ((int)(voice)->transitionTicksTotal - (int)(voice)->transitionTicks) \
                          / (int)(voice)->transitionTicksTotal))

/// @brief Set only the MSB of a 14-bit value
#define SET_MSB(target, val)                   \
    do                                         \
    {                                          \
        uint16_t new14bitVal = ((val) & 0x7F); \
        new14bitVal <<= 7;                     \
        new14bitVal |= ((target) & 0x7F);      \
        (target) = new14bitVal;                \
    } while (0)

/// @brief Set only the LSB of a 14-bit value
#define SET_LSB(target, val)                           \
    do                                                 \
    {                                                  \
        uint16_t new14bitVal = ((target) >> 7) & 0x7F; \
        new14bitVal <<= 7;                             \
        new14bitVal |= ((val) & 0x7F);                 \
        (target) = new14bitVal;                        \
    } while (0)

// Values for the percussion special states bitmap
#define SHIFT_HI_HAT   (0)
#define SHIFT_WHISTLE  (6)
#define SHIFT_GUIRO    (12)
#define SHIFT_CUICA    (18)
#define SHIFT_TRIANGLE (24)

#define MASK_HI_HAT   (0x3F)
#define MASK_WHISTLE  (0x3F << SHIFT_WHISTLE)
#define MASK_GUIRO    (0x3F << SHIFT_GUIRO)
#define MASK_CUICA    (0x3F << SHIFT_CUICA)
#define MASK_TRIANGLE (0x3F << SHIFT_TRIANGLE)

// Represents that no voice has been allocated to the instrument, within the special states bitmap
#define VOICE_FREE (0x3F)

static midiPlayer_t* globalPlayers = NULL;

static uint32_t allocVoice(const voiceStates_t* states, uint8_t voiceCount);
static bool releaseNote(voiceStates_t* states, uint8_t voiceIdx, midiVoice_t* voice);
static void midiStepVoice(midiChannel_t* channel, voiceStates_t* states, uint8_t voiceIdx, midiVoice_t* voice);
static void setVoiceTimbre(midiVoice_t* voice, midiTimbre_t* timbre);
static void initTimbre(midiTimbre_t* dest, const midiTimbre_t* config);
static const midiTimbre_t* getTimbreForProgram(bool percussion, uint8_t bank, uint8_t program);
static int32_t midiSumPercussion(midiPlayer_t* player);
static void handleMidiEvent(midiPlayer_t* player, const midiStatusEvent_t* event);
static void handleSysexEvent(midiPlayer_t* player, const midiSysexEvent_t* sysex);
static void handleMetaEvent(midiPlayer_t* player, const midiMetaEvent_t* event);
static void handleEvent(midiPlayer_t* player, const midiEvent_t* event);
static void midiSongEnd(midiPlayer_t* player);

// Check for the first unused note, then try to steal one in order of less to more bad, and return INT32_MAX if none are
// available
/**
 * @brief Return the index of an unallocated voice from the given voice pool.
 *
 * This function finds the voice index to allocate, but the caller is responsible for updating the state
 * bitmaps to actuallymark it as allocated.
 * If there are no unallocated voices remaining, an allocated voice index may be returned.
 *
 * @param states A pointer to the voice state bitmaps for this pool
 * @param voiceCount The number of voices in this pool
 * @return uint32_t The index of the voice to allocate
 */
static uint32_t allocVoice(const voiceStates_t* states, uint8_t voiceCount)
{
    uint32_t allStates = VS_ANY(states) | states->held | states->attack | states->decay | states->release
                         | states->sustain | states->sustenuto;

    // Set up a bitflag which has a 1 set for every voice that is NOT being used
    //                         /- flip the bits so a 1 represents an unused voice and a 0 represents an in-use voice
    //                        /                /- mask the bits to only go up to the number of voices we have
    //                       v                v
    uint32_t unusedVoices = (~allStates) & (0xFFFFFFFFu >> (32 - voiceCount));

    if (unusedVoices != 0)
    {
        // Return whatever the first voice that's not allocated is
        return __builtin_ctz(unusedVoices);
    }
    else
    {
        // No unused voices!
        // Try a different approach, treat notes in release state as not in use to hopefully steal one of those
        allStates &= ~states->release;
        unusedVoices = (~allStates) & (0xFFFFFFFFu >> (32 - voiceCount));
        if (unusedVoices != 0)
        {
            return __builtin_ctz(unusedVoices);
        }

        // Gotta steal a note, so steal the first one
        return 0;
    }
}

/**
 * @brief Release a note and transition it to the release state if it has one
 *
 * @param states The voice state bitmap
 * @param voiceIdx The index of this voice in the bitmap
 * @param voice A pointer to the actual voice which is used to determine the transition
 * @return true if the note should be deallocated
 * @return false if the note is still playing and should remain allocated
 */
static bool releaseNote(voiceStates_t* states, uint8_t voiceIdx, midiVoice_t* voice)
{
    uint32_t voiceBit = 1 << voiceIdx;
    uint32_t mask     = UINT32_MAX & ~voiceBit;

    uint8_t oscVol       = 0;
    uint32_t releaseTime = voice->timbre->envelope.releaseTime
                           + ((voice->timbre->envelope.releaseTimeVel * (int8_t)voice->velocity) >> 8);
    uint32_t sustainVol
        = voice->timbre->envelope.sustainVol + ((voice->timbre->envelope.sustainVolVel * (int)voice->velocity) >> 8);

    // We don't care what state the note is in, as long as it's not already in the release state
    if ((0 == (states->release & voiceBit)) && releaseTime)
    {
        // Release time will take some
        states->release |= voiceBit;
        // start the transition at the current calculated volume
        if (states->sustain & voiceBit)
        {
            voice->transitionStartVol = sustainVol;
        }
        else if (voice->transitionTicksTotal)
        {
            voice->transitionStartVol = VOICE_CUR_VOL(voice);
        }
        else
        {
            voice->transitionStartVol = voice->velocity << 1 | 1;
        }

        voice->transitionTicksTotal = voice->transitionTicks = releaseTime;
        voice->targetVol                                     = 0;

        // Calculate the rate at which the volume will adjust based on the state transition length
        oscVol = voice->transitionStartVol; // VOICE_CUR_VOL(voice);
    }
    else if (releaseTime)
    {
        // Already in release... ok, just get the current volume then
        oscVol = VOICE_CUR_VOL(voice);
    }
    else
    {
        // No release time, just end it immediately
        oscVol                      = 0;
        voice->transitionTicksTotal = voice->transitionTicks = UINT32_MAX;
        voice->targetVol                                     = 0;
    }

    // Unconditionally unset the voice for all states
    states->on &= mask;
    states->attack &= mask;
    states->decay &= mask;
    states->sustain &= mask;

    for (uint8_t i = 0; i < OSC_PER_VOICE; i++)
    {
        swSynthSetVolume(&voice->oscillators[i], oscVol);

        // add up the actual current oscillator volume
    }

    if (0 == releaseTime)
    {
        // If there's no volume on any oscillator, then the note is done playing
        states->release &= mask;
        return true;
    }

    return false;
}

void midiStepVoice(midiChannel_t* channels, voiceStates_t* states, uint8_t voiceIdx, midiVoice_t* voice)
{
    uint32_t voiceBit    = 1 << voiceIdx;
    uint32_t pressureVol = voice->velocity << 1 | 1;

    // While we're in the sustain state, don't bother checking for transitions
    if (voice->transitionTicks != UINT32_MAX)
    {
        while (!voice->transitionTicks)
        {
            uint32_t sustainVol = CLAMP(voice->timbre->envelope.sustainVol
                                            + ((voice->timbre->envelope.sustainVolVel * (int)voice->velocity) >> 8),
                                        0, 255);

            if (states->attack & voiceBit)
            {
                // Current state: ATTACK --> DECAY
                states->attack &= ~voiceBit;
                states->decay |= voiceBit;

                uint32_t decayTime = voice->timbre->envelope.decayTime
                                     + ((voice->timbre->envelope.attackTimeVel * (int)voice->velocity) >> 8);

                if (voice->transitionTicksTotal)
                {
                    // Attack time is > 0
                    voice->transitionStartVol = VOICE_CUR_VOL(voice);
                }
                else
                {
                    // Attack time == 0, so we go straight to the attack target
                    voice->transitionStartVol = voice->targetVol;
                }

                voice->transitionTicksTotal = voice->transitionTicks = decayTime;
                voice->targetVol = (uint8_t)(((voice->transitionStartVol * sustainVol) >> 8) & 0xFF);
                pressureVol      = voice->targetVol;
            }
            else if (states->decay & voiceBit)
            {
                states->decay &= ~voiceBit;

                // Ok so we're going from DECAY to SUSTAIN, sustain lasts forever
                // BUT - we only go to sustain IF the note is still ON (via key on, hold, or sustenuto)
                // Otherwise, we skip straight to release
                if ((voiceBit & (states->on | states->held | states->sustenuto)) && sustainVol)
                {
                    // Go to sustain
                    states->sustain |= voiceBit;

                    // Sustain lasts forever! As long as the note is on/held/sustenuto'd
                    if (voice->transitionTicksTotal)
                    {
                        voice->transitionStartVol = VOICE_CUR_VOL(voice);
                    }
                    else
                    {
                        voice->transitionStartVol = voice->targetVol;
                    }

                    pressureVol = voice->transitionStartVol;

                    voice->targetVol            = (pressureVol * sustainVol) >> 8;
                    voice->transitionTicksTotal = UINT32_MAX;
                    voice->transitionTicks      = UINT32_MAX;

                    // No need to set the transition times or volume, it was done already

                    // Break because the loop doesn't check for UINT32_MAX, just 0
                    break;
                }
                else
                {
                    // Go to release!
                    states->release |= voiceBit;

                    // Calculate how long the release fadeout will take
                    uint32_t releaseTime = voice->timbre->envelope.releaseTime
                                           + ((voice->timbre->envelope.releaseTimeVel * (int8_t)voice->velocity) >> 8);

                    // Save the start volume to current volume and the target to 0
                    if (voice->transitionTicksTotal)
                    {
                        voice->transitionStartVol = VOICE_CUR_VOL(voice);
                    }
                    else
                    {
                        voice->transitionStartVol = voice->targetVol;
                    }

                    pressureVol      = voice->transitionStartVol;
                    voice->targetVol = 0;

                    // Set the transition length accordingly
                    voice->transitionTicksTotal = voice->transitionTicks = releaseTime;
                }
            }
            else if (states->release & voiceBit)
            {
                // Transition from RELEASE to OFF
                states->release &= ~voiceBit;
                states->on &= ~voiceBit;
                channels[voice->channel].allocedVoices &= ~voiceBit;

                pressureVol = 0;

                if (voice->transitionTicksTotal)
                {
                    voice->transitionStartVol = VOICE_CUR_VOL(voice);
                }
                else
                {
                    voice->transitionStartVol = voice->velocity << 1 | 1;
                }

                voice->targetVol = 0;

                voice->transitionTicksTotal = UINT32_MAX;
                voice->transitionTicks      = UINT32_MAX;
                // Note's done, don't need to check again
                break;
            }
            else
            {
                voice->transitionTicksTotal = voice->transitionTicks = UINT32_MAX;
                voice->targetVol                                     = 0;
                break;
            }
        }

        voice->transitionTicks--;
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////

    // By defualt, use the pressure volume for the oscillator
    uint8_t oscVol = pressureVol;

    // TODO: I think the logic here might cause something worse:TM: than clipping?

    // Make sure we're in a transitionable state and wouldn't do a divide-by-zero to interpolate the target volume
    if (voice->transitionTicksTotal != UINT32_MAX)
    {
        // Calculate the rate at which the volume will adjust based on the state transition length
        oscVol = VOICE_CUR_VOL(voice);
    }

    if (voice->timbre->type != SAMPLE)
    {
        for (int i = 0; i < OSC_PER_VOICE; i++)
        {
            swSynthSetVolume(&voice->oscillators[i], oscVol);
        }
    }
}

/**
 * @brief Set the timbre (instrument definition) of a MIDI voice
 *
 * @param voice The voice to set the timbre for
 * @param timbre A pointer to the MIDI timbre
 */
static void setVoiceTimbre(midiVoice_t* voice, midiTimbre_t* timbre)
{
    voice->timbre = timbre;
    for (uint8_t oscIdx = 0; oscIdx < OSC_PER_VOICE; oscIdx++)
    {
        switch (timbre->type)
        {
            case WAVETABLE:
            {
                swSynthSetWaveFunc(&voice->oscillators[oscIdx], timbre->waveFunc,
                                   (void*)((uintptr_t)timbre->waveIndex));
                voice->oscillators[oscIdx].chorus = (timbre->effects.chorus) >> 3;
                break;
            }

            case NOISE:
            {
                swSynthSetShape(&voice->oscillators[oscIdx], SHAPE_NOISE);
                break;
            }

            case WAVE_SHAPE:
            {
                swSynthSetShape(&voice->oscillators[oscIdx], timbre->shape);
                break;
            }

            case SAMPLE:
            {
                // Just reset the oscillators in case they were previously in-use
                swSynthSetVolume(&voice->oscillators[oscIdx], 0);
                break;
            }
        }
    }
}

/**
 * @brief Initialize a MIDI timbre from the configured version
 *
 * @param dest The destination timbre to set up
 * @param config The configured timbre to use as the template
 */
static void initTimbre(midiTimbre_t* dest, const midiTimbre_t* config)
{
    memcpy(dest, config, sizeof(midiTimbre_t));

    if (config->type == SAMPLE)
    {
        // Sample-based timbres need to do a tiny bit of data loading
        size_t sampleSize;
        // TODO should sample.data just be a uint8_t instead? We probably need to convert it anyway
        dest->sample.data  = cnfsGetFile(config->sample.config.sampleName, &sampleSize);
        dest->sample.count = (uint32_t)sampleSize;

        if (!dest->sample.data)
        {
            ESP_LOGE("MIDI", "Failed to get data for sample '%s'!", config->sample.config.sampleName);
            dest->sample.count = 0;
        }
    }
}

/**
 * @brief Return a pointer to the base timbre for the given bank and program definition
 *
 * @param bank The bank to select the instrument from, from 0 to 127 with 0 being the GM instruments
 * @param program The program number, from 0 to 127
 * @return const midiTimbre_t*
 */
static const midiTimbre_t* getTimbreForProgram(bool percussion, uint8_t bank, uint8_t program)
{
    if (percussion)
    {
        switch (bank)
        {
            case 1:
                return &donutDrumkitTimbre;

            case 0:
            default:
                return &defaultDrumkitTimbre;
        }
    }
    else
    {
        switch (bank)
        {
            case 1:
            {
                if (program < magfestTimbreCount)
                {
                    return magfestTimbres[program];
                }

                return &magfestWaveTimbre;
            }

            case 0:
            default:
                return &acousticGrandPianoTimbre;
        }
    }
}

static int32_t midiSumOscillators(midiPlayer_t* player)
{
    voiceStates_t* states = &player->poolVoiceStates;
    midiVoice_t* voices   = player->poolVoices;

    int32_t sum = 0;

    uint32_t playingVoices = states->on | states->held | states->sustenuto | states->attack | states->decay
                             | states->sustain | states->release;
    while (playingVoices != 0)
    {
        uint8_t voiceIdx = __builtin_ctz(playingVoices);
        playingVoices &= ~(1 << voiceIdx);
        midiVoice_t* voice = &(voices[voiceIdx]);

        if (!(states->on || states->held || states->sustenuto || states->attack || states->decay || states->sustain
              || states->release)
            || voice->timbre->type == SAMPLE)
        {
            continue;
        }

        synthOscillator_t* osc = &(voice->oscillators[0]);

        if (osc->tVol == 0 && osc->cVol == 0)
        {
            continue;
        }

        // Step the oscillator's accumulator
        osc->accumulator.accum32 += osc->stepSize;

        // If the oscillator's current volume doesn't match the target volume
        if (osc->cVol != osc->tVol)
        {
            // Either increment or decrement it, depending
            if (osc->cVol < osc->tVol)
            {
                osc->cVol++;
            }
            else
            {
                osc->cVol--;
            }
        }

        // Mix this oscillator's output into the sample
        uint8_t offset = 0;
        do
        {
            sum += ((osc->waveFunc((osc->accumulator.bytes[2] + oscDither[offset]) % 256, osc->waveFuncData)
                     * ((int32_t)osc->cVol))
                    >> 8);
        } while (offset++ < osc->chorus);
    }

    return sum;
}

/**
 * @brief Step each playing percussion note forward by one sample and return the raw sum
 *
 * @param player The MIDI player to sum percussion notes for
 * @return int32_t The unsigned 32-bit sample, without any headroom or clipping applied
 */
static int32_t midiSumPercussion(midiPlayer_t* player)
{
    voiceStates_t* states = &player->percVoiceStates;
    midiVoice_t* voices   = player->percVoices;

    int32_t sum = 0;

    // Ignore the 'held' flag, this is percussion!
    uint32_t playingVoices = states->on;
    while (playingVoices != 0)
    {
        uint8_t voiceIdx = __builtin_ctz(playingVoices);
        playingVoices &= ~(1 << voiceIdx);

        bool done = false;
        sum += voices[voiceIdx].timbre->percussion.playFunc(voices[voiceIdx].note, voices[voiceIdx].sampleTick++, &done,
                                                            voices[voiceIdx].percScratch,
                                                            voices[voiceIdx].timbre->percussion.data)
               * voices[voiceIdx].velocity / 127;

        if (done)
        {
            switch (voices[voiceIdx].note)
            {
                case CLOSED_HI_HAT:
                case PEDAL_HI_HAT:
                case OPEN_HI_HAT:
                {
                    player->percSpecialStates |= VOICE_FREE << SHIFT_HI_HAT;
                    break;
                }

                case SHORT_WHISTLE:
                case LONG_WHISTLE:
                {
                    player->percSpecialStates |= VOICE_FREE << SHIFT_WHISTLE;
                    break;
                }

                case SHORT_GUIRO:
                case LONG_GUIRO:
                {
                    player->percSpecialStates |= VOICE_FREE << SHIFT_GUIRO;
                    break;
                }

                case MUTE_CUICA:
                case OPEN_CUICA:
                {
                    player->percSpecialStates |= VOICE_FREE << SHIFT_CUICA;
                    break;
                }

                case MUTE_TRIANGLE:
                case OPEN_TRIANGLE:
                {
                    player->percSpecialStates |= VOICE_FREE << SHIFT_TRIANGLE;
                    break;
                }

                default:
                    break;
            }

            states->on &= ~(1 << voiceIdx);
            player->channels[voices[voiceIdx].channel].allocedVoices &= ~(1 << voiceIdx);
            voices[voiceIdx].sampleTick = 0;
            memset(voices[voiceIdx].percScratch, 0, 4 * sizeof(uint32_t));
        }
    }

    return sum;
}

static int32_t midiSumSamples(midiPlayer_t* player)
{
    voiceStates_t* states = &player->poolVoiceStates;
    midiVoice_t* voices   = player->poolVoices;

    int32_t sum = 0;

    // Ignore the 'held' flag, this is percussion!
    uint32_t playingVoices = states->on | states->held | states->sustenuto | states->attack | states->decay
                             | states->sustain | states->release;
    while (playingVoices != 0)
    {
        uint8_t voiceIdx = __builtin_ctz(playingVoices);
        playingVoices &= ~(1 << voiceIdx);

        if (voices[voiceIdx].timbre->type != SAMPLE)
        {
            // Only sample timbres past here!
            continue;
        }

        // Same rate for now -- this is the number of times we need to output each source sample
        // in order to maintain the desired speed/pitch ratio
        uq24_8 sampleRateRatio = (1 << 8) * DAC_SAMPLE_RATE_HZ / voices[voiceIdx].timbre->sample.rate;
        sampleRateRatio *= voices[voiceIdx].timbre->sample.baseNote;
        sampleRateRatio /= bendPitchWheel(voices[voiceIdx].note, player->channels[voices[voiceIdx].channel].pitchBend);
        // Assume C4 is the base note? A4? doesn't really matter
        // Divide the desired note freq

        bool done      = false;
        int32_t sample = (int)voices[voiceIdx].timbre->sample.data[voices[voiceIdx].sampleTick] - 128;

        // TODO: Possibly change to 0x08000 for rounding at the half?
        if (voices[voiceIdx].sampleError > 0x100)
        {
            voices[voiceIdx].sampleError -= 0x100;
        }
        else
        {
            do
            {
                // TODO this probably will not work if we go backwards
                voices[voiceIdx].sampleTick++;
                // We now need to omit (playRate / sampleDataRate) samples before continuing
                voices[voiceIdx].sampleError += sampleRateRatio;
                // And account for the sample we just played

                if (voices[voiceIdx].sampleTick == voices[voiceIdx].timbre->sample.count)
                {
                    if (voices[voiceIdx].sampleLoops > 0)
                    {
                        voices[voiceIdx].sampleLoops--;

                        if (!voices[voiceIdx].sampleLoops)
                        {
                            done = true;
                            break;
                        }
                        else
                        {
                            voices[voiceIdx].sampleTick = 0;
                        }
                    }
                    else
                    {
                        voices[voiceIdx].sampleTick = 0;
                    }
                }
            } while (voices[voiceIdx].sampleError < 0x100);

            voices[voiceIdx].sampleError -= 0x100;
        }

        sum += sample * voices[voiceIdx].velocity / 127;

        if (done)
        {
            states->on &= ~(1 << voiceIdx);
            player->channels[voices[voiceIdx].channel].allocedVoices &= ~(1 << voiceIdx);
            voices[voiceIdx].sampleTick  = 0;
            voices[voiceIdx].sampleLoops = 0;
            voices[voiceIdx].sampleError = 0;
        }
    }

    return sum;
}

/**
 * @brief Process a normal MIDI status event and update the player state accordingly
 *
 * @param player The MIDI player to handle the event
 * @param event The MIDI status event to handle
 */
static void handleMidiEvent(midiPlayer_t* player, const midiStatusEvent_t* event)
{
    if (event->status & 0x80)
    {
        // Normal status message
        uint8_t channel = event->status & 0x0F;
        uint8_t cmd     = (event->status >> 4) & 0x0F;

        if (player->channels[channel].ignore)
        {
            return;
        }

        switch (cmd)
        {
            // Note OFF
            case 0x8:
            {
                uint8_t midiKey  = event->data[0];
                uint8_t velocity = event->data[1];
                midiNoteOff(player, channel, midiKey, velocity);
                break;
            }

            // Note ON
            case 0x9:
            {
                uint8_t midiKey  = event->data[0];
                uint8_t velocity = event->data[1];
                midiNoteOn(player, channel, midiKey, velocity);
                break;
            }

            // AfterTouch
            case 0xA:
            {
                uint8_t midiKey  = event->data[0];
                uint8_t velocity = event->data[1];
                midiAfterTouch(player, channel, midiKey, velocity);
                break;
            }

            // Control change
            case 0xB:
            {
                midiControl_t controlId = (midiControl_t)event->data[0];
                uint8_t controlVal      = event->data[1];
                midiControlChange(player, channel, controlId, controlVal);
                break;
            }

            // Program Select
            case 0xC:
            {
                uint8_t program = event->data[0];
                midiSetProgram(player, channel, program);
                break;
            }

            // Channel Pressure
            case 0xD:
                // Maybe we don't need to implement this actually? Sounds like it's more of a keyboard event
                break;

            // Pitch bend
            case 0xE:
            {
                uint16_t range = ((event->data[1] & 0x7F) << 7) | (event->data[0] & 0x7F);
                midiPitchWheel(player, channel, range);
                break;
            }

            default:
                break;
        }
    }
    else if (event->status & 0xF0)
    {
        // System Message
    }
}

/**
 * @brief Process a non-MIDI meta-event from a file and update the player state accordingly
 *
 * @param player The MIDI player to handle the event
 * @param event The non-MIDI meta-event to handle
 */
static void handleMetaEvent(midiPlayer_t* player, const midiMetaEvent_t* event)
{
    switch (event->type)
    {
        case SEQUENCE_NUMBER:
            break;

        // Text events
        case TEXT:
        case COPYRIGHT:
        case SEQUENCE_OR_TRACK_NAME:
        case INSTRUMENT_NAME:
        case LYRIC:
        case MARKER:
        case CUE_POINT:
        {
            // Handle text, if the callback is set
            if (player->textMessageCallback)
            {
                player->textMessageCallback(event->type, event->text, event->length);
            }
            break;
        }

        // Obsolete
        case CHANNEL_PREFIX:
            break;
        case PORT_PREFIX:
            break;

        case END_OF_TRACK:
        {
            // TODO: Maybe detect if a track ends without including END_OF_TRACK and
            // synthesize one from the parser, just in case a file is malformed?
            if (player->reader.file->format == MIDI_FORMAT_2)
            {
                player->sampleCount = 0;
            }
            break;
        }

        case TEMPO:
        {
            midiSetTempo(player, event->tempo);
            break;
        }

        case SMPTE_OFFSET:
        {
            // TODO: Tempo support?
            break;
        }

        // These are informational only, we won't do anything with them here.
        case TIME_SIGNATURE:
            break;
        case KEY_SIGNATURE:
            break;

        // None supported
        case PROPRIETARY:
            break;
    }
}

/**
 * @brief Process a MIDI System-Exclusive event and update the player state accordingly
 *
 * @warning Not yet implemented
 *
 * @param player The MIDI player to handle the event
 * @param event The MIDI SysEx event to handle
 */
static void handleSysexEvent(midiPlayer_t* player, const midiSysexEvent_t* sysex)
{
    // TODO: Support SysEx commands - find some RGB ones we can yoink
    // Actually we can assign a non-registered control to R, G, and B
    // I think there's enough for every LED too assuming there's still like, 7 or so
    // AND: if possible have a sysex command (hmm) that sets all the LEDs to individual values at once

    // GM Enable (01)
    // GM Disable (02)
    // GM2 Enable (03)
    // GM Disable (00) (incorrect but I bet people are doing it because teragonaudio says to)
    uint8_t mfrLen = 1;

#ifdef DEBUG_SYSEX
    uint8_t mfrHex[3] = {0, 0, 0};
#endif

    const uint8_t* end = sysex->data + sysex->length;

    // Determine the length of the manufacturer ID so we know how many bytes to skip for the real data
    if (sysex->manufacturerId & (1 << 15))
    {
        // This is a 1-byte manufacturer ID
        mfrLen = 1;
#ifdef DEBUG_SYSEX
        mfrHex[0] = sysex->manufacturerId & ~(1 << 15);
#endif
    }
    else
    {
        // This is a 3-byte manufacturer ID
        mfrLen = 3;
#ifdef DEBUG_SYSEX
        mfrHex[1] = (sysex->manufacturerId >> 7) & 0x7F;
        mfrHex[2] = (sysex->manufacturerId & 0x7F);
#endif
    }

    const uint8_t* dataPtr = sysex->data + mfrLen;

#ifdef DEBUG_SYSEX
    printf("Got SysEx event length=%" PRIu32 ":\n", sysex->length);
    printf("Manufacturer: ");

    for (int i = 0; i < mfrLen; i++)
    {
        printf("%02" PRIx8 " ", mfrHex[i]);
    }
    printf("\n");

    for (uint32_t i = 0; i < sysex->length; i++)
    {
        if (i % 8 == 0)
        {
            printf("\n%04" PRIx32 "    ", i);
        }

        printf("%02" PRIx8 " ", sysex->data[i]);
    }

    printf("\n");
#endif

    switch (sysex->manufacturerId)
    {
        case MMFR_EDUCATIONAL_USE:
            break;

        case MMFR_UNIVERSAL_NON_REAL_TIME:
        case MMFR_UNIVERSAL_REAL_TIME:
        {
            bool realTime = (sysex->manufacturerId == MMFR_UNIVERSAL_REAL_TIME);

            // Universal SysEx messages have 127 "channel" values, with 0x7F meaning "Disregard Channel"
            // uint8_t sysexChannel = *dataPtr++;

            if (dataPtr >= end)
            {
                // Err
                return;
            }

            uint8_t subId = *dataPtr++;

            if (dataPtr >= end)
            {
                // Err
                return;
            }

            uint8_t subId2 = *dataPtr++;

            if (realTime)
            {
                // Real Time Universal SysEx
                switch (subId)
                {
                    // 0: UNUSED
                    case 0x0:
                    // MIDI Time Code
                    case 0x1:
                    // MIDI Show Control
                    case 0x2:
                    // Notation Information
                    case 0x3:
                        break;

                    // Device Control
                    case 0x4:
                    {
                        switch (subId2)
                        {
                            // Master Volume
                            case 1:
                            {
                                break;
                            }

                            // Master Balance
                            case 2:
                                break;

                            // Master Fine Tuning
                            case 3:
                            {
                                break;
                            }

                            // Master Coarse Tuning
                            case 4:
                            {
                                break;
                            }

                            case 5:
                            default:
                                break;
                        }

                        break;
                    }

                    // Real Time MTC Cueing
                    case 0x5:
                    // MIDI Machine Control Commands
                    case 0x6:
                    // MIDI Machine Control Responses
                    case 0x7:
                    // MIDI Tuning Standard (Real Time)
                    case 0x8:
                    // Controller Destination Setting
                    case 0x9:
                    // Key-based Instrument Control
                    case 0xA:
                    // Scalable Polyphony MIDI MIP Message
                    case 0xB:
                    // Mobile Phone Control Message
                    case 0xC:
                    default:
                        break;
                }
            }
            else
            {
                // Non-Real Time Universal SysEx
                switch (subId)
                {
                    // 0: UNUSED
                    case 0x0:
                    // Sample Dump
                    case 0x1:
                    // Sample Data Packet
                    case 0x2:
                    // Sample Dump Request
                    case 0x3:
                    // MIDI Time Code
                    case 0x4:
                    // Sample Dump Extensions
                    case 0x5:
                    // General Information
                    case 0x6:
                    // File Dump
                    case 0x7:
                    // MIDI Tuning Standard
                    case 0x8:
                        break;

                    // General MIDI
                    case 0x9:
                    {
                        switch (subId2)
                        {
                            case 0:
                            {
                                // NOTE: This value is NOT defined by the MIDI spec
                                // However, some resources incorrectly claim that a value of `0` for sub-ID 2 is the
                                // value for a "GM Off" event (with `1` being "GM On"), even though a value of `2` is
                                // specified for `GM Off`, so it is possible that a `0` value will be sent with the
                                // intent to disable GM.
                                midiGmOff(player);
                                break;
                            }

                            // General MIDI 1 On
                            case 1:
                            {
                                midiGmOn(player);
                                break;
                            }

                            // General MIDI Off
                            case 2:
                            {
                                midiGmOff(player);
                                break;
                            }

                            // General MIDI 2 On (Unsupported)
                            case 3:
                            default:
                                break;
                        }
                        break;
                    }

                    // Downloadable Sounds
                    case 0xA:
                    // File Reference Message
                    case 0xB:
                    // MIDI Visual Control
                    case 0xC:
                    // MIDI Capability Inquiry
                    case 0xD:
                    // End of File
                    case 0x7B:
                    // Wait
                    case 0x7C:
                    // Cancel
                    case 0x7D:
                    // NAK
                    case 0x7E:
                    // ACK
                    case 0x7F:
                    default:
                        break;
                }
            }

            break;
        }
    }
}

/**
 * @brief Process MIDI event of any type and update the player state accordingly
 *
 * @param player The MIDI player to handle the event
 * @param event The MIDI event to handle
 */
static void handleEvent(midiPlayer_t* player, const midiEvent_t* event)
{
    switch (event->type)
    {
        case MIDI_EVENT:
        {
            handleMidiEvent(player, &event->midi);
            break;
        }

        case META_EVENT:
        {
            handleMetaEvent(player, &event->meta);
            break;
        }

        case SYSEX_EVENT:
        {
            handleSysexEvent(player, &event->sysex);
            break;
        }
    }
}

static void midiSongEnd(midiPlayer_t* player)
{
    for (uint8_t ch = 0; ch < MIDI_CHANNEL_COUNT; ch++)
    {
        midiAllNotesOff(player, 0);
    }

    if (player->loop && player->mode == MIDI_FILE && player->reader.file)
    {
        resetMidiParser(&player->reader);
        player->sampleCount = 0;
        player->paused      = false;
    }
    else
    {
        player->paused = true;
    }

    if (player->songFinishedCallback)
    {
        player->songFinishedCallback();
    }
}

void midiPlayerInit(midiPlayer_t* player)
{
    // Zero out EVERYTHING
    memset(player, 0, sizeof(midiPlayer_t));

    // Initialize the oscillators and count them
    for (int voiceIdx = 0; voiceIdx < POOL_VOICE_COUNT + PERCUSSION_VOICES; voiceIdx++)
    {
        bool percussion = voiceIdx >= POOL_VOICE_COUNT;
        midiVoice_t* voice
            = percussion ? (&player->percVoices[voiceIdx - POOL_VOICE_COUNT]) : (&player->poolVoices[voiceIdx]);
        for (uint8_t oscIdx = 0; oscIdx < OSC_PER_VOICE; oscIdx++)
        {
            swSynthInitOscillatorWave(&voice->oscillators[oscIdx], waveTableFunc, (void*)((uint32_t)0), 0, 0);
#ifdef OSC_DITHER
            voice->oscillators[oscIdx].accumulator.bytes[3]
                = (oscDither[player->oscillatorCount % ARRAY_SIZE(oscDither)]) & 0xFF;
#endif
            player->allOscillators[player->oscillatorCount++] = &voice->oscillators[oscIdx];
        }

        voice->timbre = percussion ? &defaultDrumkitTimbre : &acousticGrandPianoTimbre;
    }

    // Set up the values which must be non-zero
    midiPlayerReset(player);
}

void midiPlayerReset(midiPlayer_t* player)
{
    midiAllSoundOff(player);
    midiGmOff(player);

    // We need the tempo to not be zero, so set it to the default of 120BPM until we get a tempo event
    // 120 BPM == 500,000 microseconds per quarter note
    player->tempo = 500000;

    // Set all the relevant bits to 1, meaning not in use
    player->percSpecialStates = 0b00111111111111111111111111111111; // 0x4fffffff

    player->sampleCount    = 0;
    player->clipped        = 0;
    player->eventAvailable = false;
    player->volume         = UINT14_MAX;
    player->headroom       = MIDI_DEF_HEADROOM;

    deinitMidiParser(&player->reader);
    player->paused = true;
}

int32_t midiPlayerStep(midiPlayer_t* player)
{
    if (player->paused)
    {
        return 0;
    }

    bool checkEvents = true;
    if (player->mode == MIDI_FILE)
    {
        if (!player->eventAvailable)
        {
            player->eventAvailable = midiNextEvent(&player->reader, &player->pendingEvent);
        }

        if (!player->eventAvailable)
        {
            ESP_LOGI("MIDI", "Done playing file!");
            midiSongEnd(player);
            checkEvents = false;
        }

        // Use a while loop since we may need to handle multiple events at the exact same time
        while (checkEvents
               && player->pendingEvent.absTime
                      <= SAMPLES_TO_MIDI_TICKS(player->sampleCount, player->tempo, player->reader.division))
        {
            // It's time, so handle the event now
            handleEvent(player, &player->pendingEvent);

            // Try and grab the next event, and if we got one, keep checking
            player->eventAvailable = midiNextEvent(&player->reader, &player->pendingEvent);
            checkEvents            = player->eventAvailable;
        }
    }
    else if (player->mode == MIDI_STREAMING)
    {
        if (player->streamingCallback)
        {
            while (player->streamingCallback(&player->pendingEvent))
            {
                handleEvent(player, &player->pendingEvent);
            }
        }
    }

    // Handle ADSR transitions, etc. for all voices
    uint32_t activeVoices
        = player->poolVoiceStates.on | player->poolVoiceStates.held | player->poolVoiceStates.sustenuto
          | player->poolVoiceStates.release; // player->poolVoiceStates.attack | player->poolVoiceStates.decay |
                                             // player->poolVoiceStates.sustain | player->poolVoiceStates.release;
    while (0 != activeVoices)
    {
        uint8_t voiceIdx = __builtin_ctz(activeVoices);
        midiStepVoice(player->channels, &player->poolVoiceStates, voiceIdx, &player->poolVoices[voiceIdx]);
        activeVoices &= ~(1 << voiceIdx);
    }

    // TODO: Sample support
    // sample += samplerSumSamplers(player->allSamplers, player->samplerCount)
    int32_t sample
        = midiSumOscillators(player); // swSynthSumOscillators(player->allOscillators, player->oscillatorCount);
    sample += midiSumPercussion(player);
    sample += midiSumSamples(player);

    player->sampleCount++;

    // Apply the global volume value
    sample *= player->volume;
    sample /= UINT14_MAX;

    return sample;
}

void midiPlayerFillBuffer(midiPlayer_t* player, uint8_t* samples, int16_t len)
{
    if (player->seeking)
    {
        memset(samples, 128, len);
        return;
    }

    for (int16_t n = 0; n < len; n++)
    {
        // Step the state forward by one sample and return the next sample sum
        int32_t sample = midiPlayerStep(player);

        // Multiply the sample by 0.3 to provide some headroom for stacking samples
        sample *= player->headroom;
        sample >>= 16;

        if (sample < -128)
        {
            samples[n] = 0;
            player->clipped++;
        }
        else if (sample > 127)
        {
            samples[n] = 255;
            player->clipped++;
        }
        else
        {
            samples[n] = sample + 128;
        }
    }
}

void midiPlayerFillBufferMulti(midiPlayer_t* players, uint8_t playerCount, uint8_t* samples, int16_t len)
{
    for (int16_t n = 0; n < len; n++)
    {
        int32_t sample = 0;
        for (int i = 0; i < playerCount; i++)
        {
            if (players[i].seeking)
            {
                continue;
            }

            // Apply the player's headroom to its sample sum
            sample += (midiPlayerStep(&players[i]) * players[i].headroom);
        }

        // Shift right by 16 to account for the headroom application
        sample >>= 16;

        // TODO: Can't keep track of clipping here... does it matter?
        if (sample < -128)
        {
            samples[n] = 0;
        }
        else if (sample > 127)
        {
            samples[n] = 255;
        }
        else
        {
            samples[n] = sample + 128;
        }
    }
}

void midiAllSoundOff(midiPlayer_t* player)
{
    // TODO: It is unclear whether this applies to every channel or just one
    // Seems like people "agree" it's special and applies to every channel
    // But also people say the spec is deficient in this area.
    // So if it's up to us, let's just do them all!

    for (uint8_t voiceIdx = 0; voiceIdx < POOL_VOICE_COUNT; voiceIdx++)
    {
        // Here we don't bother to check whether each voice is being used, since we want
        // to turn them off no matter what. This is because All Sounds Off is often used
        // as a "panic" button to stop any stuck notes. So, just in case we get in a bad
        // state where notes are playing but we don't "think" they are, this will always
        // stop them anyway.
        // TODO: Maybe move this all into a stopVoice() function
        player->poolVoices[voiceIdx].transitionTicks = 0;
        player->poolVoices[voiceIdx].targetVol       = 0;
        player->poolVoiceStates.held                 = 0;
        player->poolVoiceStates.sustenuto            = 0;
        player->poolVoiceStates.attack               = 0;
        player->poolVoiceStates.decay                = 0;
        player->poolVoiceStates.sustain              = 0;
        player->poolVoiceStates.release              = 0;
        player->poolVoiceStates.on                   = 0;
        // TODO: Handle samplers
        for (uint8_t oscIdx = 0; oscIdx < OSC_PER_VOICE; oscIdx++)
        {
            swSynthSetVolume(&player->poolVoices[voiceIdx].oscillators[oscIdx], 0);
            swSynthSetFreqPrecise(&player->poolVoices[voiceIdx].oscillators[oscIdx], 0);
        }
    }

    for (uint8_t voiceIdx = 0; voiceIdx < PERCUSSION_VOICES; voiceIdx++)
    {
        player->percVoices[voiceIdx].transitionTicks = 0;
        player->percVoices[voiceIdx].targetVol       = 0;
        player->percVoiceStates.held                 = 0;
        player->percVoiceStates.on                   = 0;
        for (uint8_t oscIdx = 0; oscIdx < OSC_PER_VOICE; oscIdx++)
        {
            player->percVoices[voiceIdx].targetVol = 0;
            swSynthSetVolume(&player->percVoices[voiceIdx].oscillators[oscIdx], 0);
            swSynthSetFreqPrecise(&player->percVoices[voiceIdx].oscillators[oscIdx], 0);
        }
    }

    for (int chanIdx = 0; chanIdx < MIDI_CHANNEL_COUNT; chanIdx++)
    {
        midiChannel_t* chan = &player->channels[chanIdx];
        chan->allocedVoices = 0;
        chan->held          = false;
        chan->sustenuto     = false;
    }
}

void midiResetChannelControllers(midiPlayer_t* player, uint8_t channel)
{
    midiChannel_t* chan = &player->channels[channel];
    midiSustain(player, channel, MIDI_FALSE);
    chan->volume              = UINT14_MAX;
    chan->pitchBend           = PITCH_BEND_CENTER;
    chan->registeredParameter = true;
    // Set selected RPN to "RPN Reset" which means none currently selected
    chan->selectedParameter = UINT14_MAX;
    chan->program           = 0;
    chan->held              = 0;
    chan->sustenuto         = 0;
    initTimbre(&chan->timbre, getTimbreForProgram(chan->percussion, chan->bank, chan->program));
}

void midiGmOn(midiPlayer_t* player)
{
    for (uint8_t chanIdx = 0; chanIdx < MIDI_CHANNEL_COUNT; chanIdx++)
    {
        midiChannel_t* chan = &player->channels[chanIdx];

        midiResetChannelControllers(player, chanIdx);

        // Channel 10 (index 9) is reserved for percussion.
        chan->percussion = (9 == chanIdx);
        chan->bank       = 0;

        initTimbre(&chan->timbre, getTimbreForProgram(chan->percussion, 0, chan->program));
    }
}

void midiGmOff(midiPlayer_t* player)
{
    for (uint8_t chanIdx = 0; chanIdx < MIDI_CHANNEL_COUNT; chanIdx++)
    {
        midiChannel_t* chan = &player->channels[chanIdx];

        midiResetChannelControllers(player, chanIdx);

        // Channel 10 (index 9) is reserved for percussion.
        // Also enable percussion on channel 11 (index 10) with an alternate drum kit
        chan->percussion = (9 == chanIdx || 10 == chanIdx);
        // Set bank 1 (MAGFest sounds) for everything except the first drumkit on 10
        chan->bank = (9 == chanIdx) ? 0 : 1;

        switch (chanIdx)
        {
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            {
                chan->program = chanIdx;
                break;
            }

            case 9:
            case 10:
            {
                chan->program = 0;
                break;
            }

            case 11:
            case 12:
            case 13:
            case 14:
            case 15:
            {
                chan->program = 0;
                break;
            }
        }

        initTimbre(&chan->timbre, getTimbreForProgram(chan->percussion, chan->bank, chan->program));
    }
}

void midiAllNotesOff(midiPlayer_t* player, uint8_t channel)
{
    midiChannel_t* chan   = &player->channels[channel];
    voiceStates_t* states = chan->percussion ? &player->percVoiceStates : &player->poolVoiceStates;

    uint32_t playingVoices = VS_ANY(states) | states->held;
    while (playingVoices != 0)
    {
        // TODO / FIXME: This causes an additional search for the playing channel which is unnecessary
        // Instead, refactor the core of midiNoteOff() into an internal midiVoiceOff() function
        // That's probably a good idea anyway with how complicated midiNoteOff() is getting
        uint8_t voiceIdx = __builtin_ctz(playingVoices);
        midiNoteOff(player, channel, player->poolVoices[voiceIdx].note, 0x7F);

        playingVoices &= ~(1 << voiceIdx);
    }
}

void midiNoteOn(midiPlayer_t* player, uint8_t chanId, uint8_t note, uint8_t velocity)
{
    if (velocity == 0)
    {
        // MIDI note on with a value of 0 is considered a note off
        midiNoteOff(player, chanId, note, 0x7F);
        return;
    }

    midiChannel_t* chan = &player->channels[chanId];
    // Use the appropriate voice pool for the instrument type
    // Percussion gets its own
    voiceStates_t* states = chan->percussion ? &player->percVoiceStates : &player->poolVoiceStates;
    midiVoice_t* voices   = chan->percussion ? player->percVoices : player->poolVoices;
    uint8_t voiceCount    = chan->percussion ? PERCUSSION_VOICES : POOL_VOICE_COUNT;
    uint32_t voiceIdx     = allocVoice(states, voiceCount);

    if (chan->timbre.flags & TF_MONO)
    {
        if (chan->allocedVoices)
        {
            voiceIdx = chan->allocedVoices;
        }
    }

    if (chan->percussion)
    {
        // handle special cases for percussion instruments
        // this will check if a mutually exclusive note is already playing on a voice and cut it off with the new one
        switch (note)
        {
            case CLOSED_HI_HAT:
            case PEDAL_HI_HAT:
            case OPEN_HI_HAT:
            {
                uint8_t hiHatVoice = player->percSpecialStates & MASK_HI_HAT;
                if (hiHatVoice != VOICE_FREE)
                {
                    voiceIdx = hiHatVoice;
                }
                else
                {
                    player->percSpecialStates = (player->percSpecialStates & ~MASK_HI_HAT) | (voiceIdx << SHIFT_HI_HAT);
                }
                break;
            }

            case SHORT_WHISTLE:
            case LONG_WHISTLE:
            {
                uint8_t whistleVoice = (player->percSpecialStates & MASK_WHISTLE) >> SHIFT_WHISTLE;
                if (whistleVoice != VOICE_FREE)
                {
                    voiceIdx = whistleVoice;
                }
                else
                {
                    player->percSpecialStates
                        = (player->percSpecialStates & ~MASK_WHISTLE) | (voiceIdx << SHIFT_WHISTLE);
                }
                break;
            }

            case SHORT_GUIRO:
            case LONG_GUIRO:
            {
                uint8_t guiroVoice = (player->percSpecialStates & MASK_GUIRO) >> SHIFT_GUIRO;
                if (guiroVoice != VOICE_FREE)
                {
                    voiceIdx = guiroVoice;
                }
                else
                {
                    player->percSpecialStates = (player->percSpecialStates & ~MASK_GUIRO) | (voiceIdx << SHIFT_GUIRO);
                }
                break;
            }

            case MUTE_CUICA:
            case OPEN_CUICA:
            {
                uint8_t cuicaVoice = (player->percSpecialStates & MASK_CUICA) >> SHIFT_CUICA;
                if (cuicaVoice != VOICE_FREE)
                {
                    voiceIdx = cuicaVoice;
                }
                else
                {
                    player->percSpecialStates = (player->percSpecialStates & ~MASK_CUICA) | (voiceIdx << SHIFT_CUICA);
                }
                break;
            }

            case MUTE_TRIANGLE:
            case OPEN_TRIANGLE:
            {
                uint8_t triangleVoice = (player->percSpecialStates & MASK_TRIANGLE) >> SHIFT_TRIANGLE;
                if (triangleVoice != VOICE_FREE)
                {
                    voiceIdx = triangleVoice;
                }
                else
                {
                    player->percSpecialStates
                        = (player->percSpecialStates & ~MASK_TRIANGLE) | (voiceIdx << SHIFT_TRIANGLE);
                }
                break;
            }

            default:
                break;
        }

        // Handle the rest of the percussion notes normally, or handle the case where there was no conflict
    }

    if (voiceIdx >= voiceCount)
    {
        // no voices available and we couldn't find an appropriate one to steal
        // if this happens often we should just allocate more voices
        // (or make the stealing algorithm always succeed)
        return;
    }

    uint32_t voiceBit = (1 << voiceIdx);

    bool stolen = 0
                  != (voiceBit
                      & (states->on | states->held | states->sustenuto | states->attack | states->decay
                         | states->sustain | states->release));

    // Not good -- we need to figure out who was using this voice before, and clear it
    // This is necessary to fix stuck notes, but doesn't take care of everything
    if (stolen)
    {
        uint8_t stolenChannel = voices[voiceIdx].channel;
        if (player->channels[stolenChannel].percussion == chan->percussion
            && (player->channels[stolenChannel].allocedVoices & voiceBit))
        {
            player->channels[stolenChannel].allocedVoices &= ~voiceBit;
            // Unnecessary but I'll keep it here for clarity, and the compiler can get rid of it
            states->on &= ~voiceBit;
            states->held &= ~voiceBit;
            states->sustenuto &= ~voiceBit;
            states->attack &= ~voiceBit;
            states->decay &= ~voiceBit;
            states->sustain &= ~voiceBit;
            states->release &= ~voiceBit;
        }
    }

    midiVoice_t* voice = &voices[voiceIdx];

    chan->allocedVoices |= voiceBit;
    states->on |= voiceBit;
    voice->note     = note;
    voice->channel  = chanId;
    voice->velocity = velocity;

    // TODO: Add a note -> voice map in the channel?

    // Ensure the selected voice will play with the right instrument
    setVoiceTimbre(voice, &chan->timbre);

    if ((chan->timbre.flags & TF_PERCUSSION))
    {
        // Reset the percussion voice state
        voice->sampleTick = 0;
    }
    else if (chan->timbre.type == SAMPLE)
    {
        voice->sampleTick  = 0;
        voice->sampleError = 0;
        voice->sampleLoops = chan->timbre.sample.loop;
    }
    else
    {
        // The volume based on the note velocity, used for the attack volume
        uint8_t pressureVol = velocity << 1 | 1;
        uint32_t attackTime
            = chan->timbre.envelope.attackTime + ((chan->timbre.envelope.attackTimeVel * (int8_t)velocity) >> 8);

        voice->transitionTicks = voice->transitionTicksTotal = attackTime;
        states->attack |= voiceBit;
        voice->transitionStartVol = 0;
        voice->targetVol          = pressureVol;

        // StepVoice() will take care of everything else

        swSynthSetVolume(&voice->oscillators[0], attackTime ? 0 : pressureVol);
        swSynthSetFreqPrecise(&voice->oscillators[0], bendPitchWheel(note, chan->pitchBend));
    }
}

void midiAfterTouch(midiPlayer_t* player, uint8_t channel, uint8_t note, uint8_t velocity)
{
    midiChannel_t* chan = &player->channels[channel];

    if (chan->percussion)
    {
        // I don't believe in percussion aftertouch
        return;
    }

    voiceStates_t* states = &player->poolVoiceStates;
    midiVoice_t* voices   = player->poolVoices;

    uint32_t playingVoices = VS_ANY(states) & chan->allocedVoices;

    // Find the channel playing this note
    while (playingVoices != 0)
    {
        uint8_t voiceIdx   = __builtin_ctz(playingVoices);
        uint32_t voiceBit  = (1 << voiceIdx);
        midiVoice_t* voice = &voices[voiceIdx];

        if (voices[voiceIdx].note == note)
        {
            uint8_t pressureVol = velocity << 1 | 1;
            // This is the one we want!
            voice->velocity = velocity;

            uint32_t sustainVol = voice->timbre->envelope.sustainVol
                                  + ((voice->timbre->envelope.sustainVolVel * (int8_t)voice->velocity) >> 8);

            if (states->attack & voiceBit)
            {
                // Attack state, set using pressure velocity
                voice->targetVol = pressureVol;
            }
            else if ((states->decay | states->sustain) & voiceBit)
            {
                //  Decay or sustain state, set using new sustain velocity
                voice->targetVol = sustainVol;
            }

            return;
        }

        // Move on to the next voice
        playingVoices &= ~voiceBit;
    }
}

void midiNoteOff(midiPlayer_t* player, uint8_t channel, uint8_t note, uint8_t velocity)
{
    midiChannel_t* chan   = &player->channels[channel];
    voiceStates_t* states = chan->percussion ? &player->percVoiceStates : &player->poolVoiceStates;
    midiVoice_t* voices   = chan->percussion ? player->percVoices : player->poolVoices;
    int32_t maxVoices     = chan->percussion ? ARRAY_SIZE(player->percVoices) : ARRAY_SIZE(player->poolVoices);

    // check the bitmaps to see if there's any note to release
    uint32_t playingVoices = VS_ANY(states) & chan->allocedVoices;

    if (chan->percussion)
    {
        switch (note)
        {
            case SHORT_WHISTLE:
            case LONG_WHISTLE:
            case SHORT_GUIRO:
            case LONG_GUIRO:
                if (chan->bank != 0)
                {
                    return;
                }
                break;

            default:
                return;
        }
    }

    // Find the channel playing this note
    while (playingVoices != 0)
    {
        uint8_t voiceIdx = __builtin_ctz(playingVoices);
        if (voiceIdx >= maxVoices)
        {
            break;
        }
        uint32_t voiceBit = (1 << voiceIdx);

        if (voices[voiceIdx].note == note)
        {
            // This is the one we want!

            // Unset the on-ness of this note
            states->on &= ~voiceBit;

            if (chan->held)
            {
                states->held |= voiceBit;
            }
            else if (!chan->sustenuto || 0 == (states->sustenuto & voiceBit))
            {
                if (releaseNote(states, voiceIdx, &voices[voiceIdx]))
                {
                    // Do not deallocate the voice until it actually finishes playing
                    chan->allocedVoices &= ~voiceBit;
                }
            }

            return;
        }

        // Move on to the next voice
        playingVoices &= ~voiceBit;
    }
}

void midiSetProgram(midiPlayer_t* player, uint8_t channel, uint8_t program)
{
    // Dynamic voice allocation somehow makes this way simpler
    player->channels[channel].program = program;

    initTimbre(&player->channels[channel].timbre,
               getTimbreForProgram(player->channels[channel].percussion, player->channels[channel].bank, program));

    // TODO: Actually define all the timbres individually instead of editing them like this
    // TODO: Remove hardcoded bank == 0 check
    if (player->channels[channel].timbre.type == WAVETABLE && player->channels[channel].bank == 0)
    {
        // It's fine for now because envelopes, etc. aren't fully implemented so the only difference is the wave index
        player->channels[channel].timbre.waveIndex = program;
    }
}

void midiSustain(midiPlayer_t* player, uint8_t channel, uint8_t val)
{
    midiChannel_t* chan = &player->channels[channel];
    bool newIsHold      = MIDI_TO_BOOL(val);

    if (chan->held != newIsHold)
    {
        voiceStates_t* voiceStates = chan->percussion ? &player->percVoiceStates : &player->poolVoiceStates;
        midiVoice_t* voices        = chan->percussion ? player->percVoices : player->poolVoices;
        if (newIsHold)
        {
            // Just set the held state for all the currently on notes.
            voiceStates->held |= chan->allocedVoices & voiceStates->on;
        }
        else
        {
            // for now what we do is just, if the note is held and not on, turn it off
            // if the note is on, just unset held
            // We should cancel all the notes which are not currently being held
            uint32_t notesToCancel = chan->allocedVoices & voiceStates->held & ~(voiceStates->on);

            // unset the hold flag for all
            // TODO: Isn't this going to always be 0?
            uint32_t newHold = (voiceStates->held & ~notesToCancel);

            // TODO Don't do it like this! Use releaseNote()

            while (notesToCancel != 0)
            {
                uint8_t voiceIdx  = __builtin_ctz(notesToCancel);
                uint32_t voiceBit = (1 << voiceIdx);

                // unset the note's bit and move on to the next one
                notesToCancel &= ~voiceBit;

                if (releaseNote(voiceStates, voiceIdx, &voices[voiceIdx]))
                {
                    chan->allocedVoices &= ~voiceBit;
                }
            }

            voiceStates->held = newHold;
        }
        chan->held = newIsHold;
    }
}

void midiSustenuto(midiPlayer_t* player, uint8_t channel, uint8_t val)
{
    midiChannel_t* chan = &player->channels[channel];
    bool newIsSust      = MIDI_TO_BOOL(val);

    if (chan->sustenuto != newIsSust)
    {
        voiceStates_t* voiceStates = chan->percussion ? &player->percVoiceStates : &player->poolVoiceStates;
        midiVoice_t* voices        = chan->percussion ? player->percVoices : player->poolVoices;

        if (newIsSust)
        {
            // Just set the sustenuto state for all the currently on notes.
            voiceStates->sustenuto |= (voiceStates->on & chan->allocedVoices);
        }
        else
        {
            // If the note is in the sustenuto state and the note is not held on by the key or sustain pedal,
            // then we cancel it.
            uint32_t notesToCancel
                = chan->allocedVoices & voiceStates->sustenuto & ~(voiceStates->on | voiceStates->held);

            // Unset all the sustenuto bits
            voiceStates->sustenuto &= ~chan->allocedVoices;

            while (notesToCancel != 0)
            {
                uint8_t voiceIdx  = __builtin_ctz(notesToCancel);
                uint32_t voiceBit = (1 << voiceIdx);

                if (releaseNote(voiceStates, voiceIdx, &voices[voiceIdx]))
                {
                    chan->allocedVoices &= ~voiceBit;
                }

                // unset the note's bit and move on to the next one
                notesToCancel &= ~voiceBit;
            }
        }
        chan->sustenuto = newIsSust;
    }
}

void midiControlChange(midiPlayer_t* player, uint8_t channel, midiControl_t control, uint8_t val)
{
    switch (control)
    {
        case MCC_BANK_MSB:
        {
            SET_MSB(player->channels[channel].bank, val);
            break;
        }

        case MCC_BANK_LSB:
        {
            SET_LSB(player->channels[channel].bank, val);
            break;
        }

        // Data Entry MSB (6)
        case MCC_DATA_ENTRY_MSB:
        {
            uint16_t curVal = midiGetParameterValue(player, channel, player->channels[channel].registeredParameter,
                                                    player->channels[channel].selectedParameter);
            SET_MSB(curVal, val);
            midiSetParameter(player, channel, player->channels[channel].registeredParameter,
                             player->channels[channel].selectedParameter, curVal);
            break;
        }

        // Data Entry LSB (38)
        case MCC_DATA_ENTRY_LSB:
        {
            uint16_t curVal = midiGetParameterValue(player, channel, player->channels[channel].registeredParameter,
                                                    player->channels[channel].selectedParameter);
            SET_LSB(curVal, val);
            midiSetParameter(player, channel, player->channels[channel].registeredParameter,
                             player->channels[channel].selectedParameter, curVal);
            break;
        }

        case MCC_VOLUME_MSB:
        {
            player->channels[channel].volume = ((val & 0x7F) << 7) | (player->channels[channel].volume & 0x7F);
            break;
        }

        // Sustain (64)
        case MCC_HOLD_PEDAL:
        {
            midiSustain(player, channel, val);
            break;
        }

        // Sustenuto (66)
        case MCC_SUSTENUTO_PEDAL:
        {
            midiSustenuto(player, channel, val);
            break;
        }

        // Sound Release Time (72)
        case MCC_SOUND_RELEASE_TIME:
        {
            // Set the release time in 10ms increments!
            // That gives us a range of 0ms to 1.270s... is that enough?
            player->channels[channel].timbre.envelope.releaseTime = MS_TO_SAMPLES(10 * val);
            break;
        }

        // Sound Attack Time (73)
        case MCC_SOUND_ATTACK_TIME:
        {
            // Also sest attack with 10ms increments
            player->channels[channel].timbre.envelope.attackTime = MS_TO_SAMPLES(10 * val);
            break;
        }

        // Decay (75) (unassigned)
        case MCC_SOUND_CONTROL_6:
        {
            player->channels[channel].timbre.envelope.decayTime = MS_TO_SAMPLES(10 * val);
            break;
        }

        // Sustain (76) (unassigned)
        case MCC_SOUND_CONTROL_7:
        {
            player->channels[channel].timbre.envelope.sustainVol = val;
            break;
        }

        // Chorus Level (93)
        case MCC_CHORUS_LEVEL:
        {
            // Set chorus (within reason, up to 16... which is kinda ridiculous anyway)
            player->channels[channel].timbre.effects.chorus = MIN(val, 16);
            break;
        }

        // Data Button Increment (96)
        case MCC_DATA_BUTTON_INC:
        // Data Button Decrement (97)
        case MCC_DATA_BUTTON_DEC:
        {
            bool inc       = (control == MCC_DATA_BUTTON_INC);
            uint16_t param = player->channels[channel].selectedParameter;
            uint16_t curVal
                = midiGetParameterValue(player, channel, player->channels[channel].registeredParameter, param);

            // Prevent rollover
            if ((inc && curVal < UINT14_MAX) || (!inc && curVal > 0))
            {
                midiSetParameter(player, channel, player->channels[channel].registeredParameter, param, curVal);
            }
            break;
        }

        // Non-registered Parameter Number LSB (98)
        case MCC_NON_REGISTERED_PARAM_LSB:
        {
            player->channels[channel].registeredParameter = false;
            SET_LSB(player->channels[channel].selectedParameter, val);
            break;
        }

        // Non-registered Parameter Number MSB (99)
        case MCC_NON_REGISTERED_PARAM_MSB:
        {
            player->channels[channel].registeredParameter = false;
            SET_MSB(player->channels[channel].selectedParameter, val);
            break;
        }

        // Registered Parameter Number LSB (100)
        case MCC_REGISTERED_PARAM_LSB:
        {
            player->channels[channel].registeredParameter = true;
            SET_LSB(player->channels[channel].selectedParameter, val);
            break;
        }

        // Registered Parameter Number MSB (101)
        case MCC_REGISTERED_PARAM_MSB:
        {
            player->channels[channel].registeredParameter = true;
            SET_MSB(player->channels[channel].selectedParameter, val);
            break;
        }

        // All sounds off (120)
        case MCC_ALL_SOUND_OFF:
        {
            midiAllSoundOff(player);
            break;
        }

        // All controllers off (121)
        case MCC_ALL_CONTROLS_OFF:
        {
            midiResetChannelControllers(player, channel);
            break;
        }

        // All notes off (123)
        case MCC_ALL_NOTE_OFF:
        {
            midiAllNotesOff(player, channel);
            break;
        }

        default:
        {
            static uint32_t state[4] = {0};
            uint8_t ctlNum           = (uint8_t)control;
            if (!(state[ctlNum / 32] & (1 << (ctlNum % 32))))
            {
                ESP_LOGI("MIDI", "Ignoring unknown/unsupported controller: %" PRIu8, ctlNum);
                state[ctlNum / 32] |= (1 << (ctlNum % 32));
            }
            return;
        }
    }
}

uint8_t midiGetControlValue(midiPlayer_t* player, uint8_t channel, midiControl_t control)
{
    switch (control)
    {
        case MCC_BANK_MSB:
            return (player->channels[channel].bank >> 7) & 0x7F;

        case MCC_BANK_LSB:
            return (player->channels[channel].bank & 0x7F);

        case MCC_HOLD_PEDAL:
            return BOOL_TO_MIDI(player->channels[channel].held);

        case MCC_SUSTENUTO_PEDAL:
            return BOOL_TO_MIDI(player->channels[channel].held);

        case MCC_SOUND_RELEASE_TIME:
            return (player->channels[channel].timbre.envelope.releaseTime * 1000 / DAC_SAMPLE_RATE_HZ / 10) & 0x7F;

        case MCC_SOUND_ATTACK_TIME:
            return (player->channels[channel].timbre.envelope.attackTime * 1000 / DAC_SAMPLE_RATE_HZ / 10) & 0x7F;

        // Decay (75) (unassigned)
        case MCC_SOUND_CONTROL_6:
            return (player->channels[channel].timbre.envelope.decayTime * 1000 / DAC_SAMPLE_RATE_HZ / 10) & 0x7F;

        // Sustain (76) (unassigned)
        case MCC_SOUND_CONTROL_7:
            return player->channels[channel].timbre.envelope.sustainVol & 0x7F;

        case MCC_CHORUS_LEVEL:
            return player->channels[channel].timbre.effects.chorus & 0x7F;

        default:
            return 0;
    }
}

uint16_t midiGetControlValue14bit(midiPlayer_t* player, uint8_t channel, midiControl_t control)
{
    uint8_t msbControl = (uint8_t)control & ~(1 << 5);
    uint8_t lsbControl = (uint8_t)control | (1 << 5);

    if (control >= 64)
    {
        // There are a couple other MSB/LSB controllers, and those have an odd MSB and an even LSB
        msbControl = (uint8_t)control | 1;
        lsbControl = (uint8_t)control & ~1;
    }

    uint16_t result = midiGetControlValue(player, channel, (midiControl_t)msbControl) & 0x7f;
    result <<= 7;
    result |= midiGetControlValue(player, channel, (midiControl_t)lsbControl) & 0x7F;
    return result;
}

void midiSetParameter(midiPlayer_t* player, uint8_t channel, bool registeredParam, uint16_t param, uint16_t value)
{
    if (registeredParam)
    {
        switch (param)
        {
            // Pitch Bend Range
            case 0x0000:
            {
                // Not supported (yet?)
                break;
            }

            // Master Fine Tuning
            case 0x0001:
            {
                // Not supported
                break;
            }

            // Master Coarse Tuning
            case 0x0002:
            {
                // Not supported
                break;
            }

            // "Not Set"
            case 0x3FFF:
            default:
            {
                // No action necessary
                break;
            }
        }
    }
    else
    {
        switch (param)
        {
            case 10:
            {
                // Set Percussion
                if ((value != 0) != player->channels[channel].percussion)
                {
                    player->channels[channel].percussion = (value != 0);
                    // Necessary to actually configure the channel for its new percussion state
                    midiSetProgram(player, channel, player->channels[channel].program);
                }
                break;
            }

            default:
            {
                // Ignore all others
                break;
            }
        }
    }
}

uint16_t midiGetParameterValue(midiPlayer_t* player, uint8_t channel, bool registered, uint16_t param)
{
    if (registered)
    {
        switch (param)
        {
            default:
                return 0;
        }
    }
    else
    {
        switch (param)
        {
            case 10:
            {
                return player->channels[channel].percussion ? 1 : 0;
            }

            default:
            {
                return 0;
            }
        }
    }
}

void midiPitchWheel(midiPlayer_t* player, uint8_t channel, uint16_t value)
{
    // Save the pitch bend value
    player->channels[channel].pitchBend = value;
    voiceStates_t* states = player->channels[channel].percussion ? &player->percVoiceStates : &player->poolVoiceStates;
    midiVoice_t* voices   = player->channels[channel].percussion ? player->percVoices : player->poolVoices;

    if (player->channels[channel].timbre.type != SAMPLE)
    {
        // Find all the voices currently sounding for this channel and update their frequencies
        uint32_t playingVoices = (VS_ANY(states) | states->held) & player->channels[channel].allocedVoices;

        while (playingVoices != 0)
        {
            uint8_t voiceIdx  = __builtin_ctz(playingVoices);
            uint32_t voiceBit = (1 << voiceIdx);

            for (uint8_t oscIdx = 0; oscIdx < OSC_PER_VOICE; oscIdx++)
            {
                // Apply the pitch bend to all this channel's oscillators
                // TODO: If each voice has multiple oscillators, we would obviously
                // want to be able to control them separately here.
                // Maybe we only apply that for like, chorus?
                swSynthSetFreqPrecise(&voices[voiceIdx].oscillators[oscIdx],
                                      bendPitchWheel(voices[voiceIdx].note, value));
            }

            // Next!
            playingVoices &= ~voiceBit;
        }
    }
}

void midiSetTempo(midiPlayer_t* player, uint32_t tempo)
{
    uint32_t oldTempo = player->tempo;

    player->tempo       = tempo;
    player->sampleCount = player->sampleCount * tempo / oldTempo;
}

void midiSetFile(midiPlayer_t* player, const midiFile_t* song)
{
    player->mode = MIDI_FILE;
    if (player->reader.states == NULL)
    {
        initMidiParser(&player->reader, song);
    }
    else if (song == NULL)
    {
        deinitMidiParser(&player->reader);
        player->mode   = MIDI_STREAMING;
        player->paused = true;
    }
    else
    {
        midiParserSetFile(&player->reader, song);
    }
}

void midiPause(midiPlayer_t* player, bool pause)
{
    player->paused = pause;
}

void midiSeek(midiPlayer_t* player, uint32_t ticks)
{
    bool paused  = player->paused;
    bool stopped = false;

    if (player->mode == MIDI_FILE && player->reader.file)
    {
        const midiFile_t* loadedFile = player->reader.file;
        midiTextCallback_t textCb    = player->textMessageCallback;
        songFinishedCbFn endCb       = player->songFinishedCallback;
        player->textMessageCallback  = NULL;
        player->songFinishedCallback = NULL;
        bool loop                    = player->loop;

        if (SAMPLES_TO_MIDI_TICKS(player->sampleCount, player->tempo, player->reader.division) > ticks)
        {
            // We have to go back
            midiPlayerReset(player);
            midiSetFile(player, loadedFile);
        }

        // Set the seeking flag so that the DAC won't get any output
        player->seeking = true;

        // Unpause the player otherwise nothing will happen
        midiPause(player, false);
        player->loop = false;

        // Okay, new strategy:
        // We work in ticks here to preserve precision
        // Calculate the current tick, use that to skip through events
        // Once the tick is up-to-date, update the sample count
        // Done!

        ESP_LOGD("MIDI", "Seeking to %" PRIu32 "\n", ticks);

        uint32_t curTick = SAMPLES_TO_MIDI_TICKS(player->sampleCount, player->tempo, player->reader.division);
        ESP_LOGD("MIDI", "Current tick is %" PRIu32 "\n", curTick);

        while (curTick < ticks)
        {
            if (!player->eventAvailable)
            {
                player->eventAvailable = midiNextEvent(&player->reader, &player->pendingEvent);
            }

            if (!player->eventAvailable || player->pendingEvent.absTime > ticks)
            {
                ESP_LOGD("MIDI", "No more events between start and end time\n");
                if ((META_EVENT == player->pendingEvent.type) && (END_OF_TRACK == player->pendingEvent.meta.type))
                {
                    curTick = player->pendingEvent.absTime;
                }
                else
                {
                    curTick = ticks;
                }
                break;
            }

            curTick = player->pendingEvent.absTime;
            ESP_LOGD("MIDI", "Next event is at tick %" PRIu32 "\n", curTick);
            player->sampleCount = TICKS_TO_SAMPLES(curTick, player->tempo, player->reader.division);
            handleEvent(player, &player->pendingEvent);
            player->eventAvailable = midiNextEvent(&player->reader, &player->pendingEvent);
        }

        player->sampleCount = TICKS_TO_SAMPLES(curTick, player->tempo, player->reader.division);

        stopped = !player->eventAvailable
                  && !(player->eventAvailable = midiNextEvent(&player->reader, &player->pendingEvent));
        if (stopped && (uint32_t)-1 != ticks)
        {
            midiSongEnd(player);

            if (endCb)
            {
                endCb();
            }
        }

        player->songFinishedCallback = endCb;
        player->textMessageCallback  = textCb;
        player->loop                 = loop;
        player->seeking              = false;
    }

    midiPause(player, paused || stopped);
}

//==============================================================================
// System-wide MIDI player functions
//==============================================================================

void initGlobalMidiPlayer(void)
{
    if (!globalPlayers)
    {
        globalPlayers = heap_caps_calloc(NUM_GLOBAL_PLAYERS, sizeof(midiPlayer_t), MALLOC_CAP_8BIT);
        for (int i = 0; i < NUM_GLOBAL_PLAYERS; i++)
        {
            midiPlayerInit(&globalPlayers[i]);
        }
    }
}

void deinitGlobalMidiPlayer(void)
{
    if (globalPlayers)
    {
        for (int i = 0; i < NUM_GLOBAL_PLAYERS; i++)
        {
            midiPause(&globalPlayers[i], true);
            midiAllSoundOff(&globalPlayers[i]);
            midiPlayerReset(&globalPlayers[i]);
        }

        heap_caps_free(globalPlayers);
        globalPlayers = NULL;
    }
}

void globalMidiPlayerFillBuffer(uint8_t* samples, int16_t len)
{
    if (globalPlayers)
    {
        midiPlayerFillBufferMulti(globalPlayers, NUM_GLOBAL_PLAYERS, samples, len);
    }
    else
    {
        memset(samples, 128, len);
    }
}

void globalMidiPlayerPlaySong(midiFile_t* song, uint8_t songIdx)
{
    initGlobalMidiPlayer();

    if (globalPlayers)
    {
        midiPause(&globalPlayers[songIdx], true);
        globalPlayers[songIdx].sampleCount = 0;
        midiSetFile(&globalPlayers[songIdx], song);
        midiPause(&globalPlayers[songIdx], false);
    }
}

void globalMidiPlayerPlaySongCb(midiFile_t* song, uint8_t songIdx, songFinishedCbFn cb)
{
    if (globalPlayers)
    {
        globalMidiPlayerPlaySong(song, songIdx);
        globalPlayers[songIdx].songFinishedCallback = cb;
    }
}

void globalMidiPlayerSetVolume(uint8_t trackType, int32_t volumeSetting)
{
    if (globalPlayers)
    {
        midiPlayer_t* player = &globalPlayers[trackType];

        if (volumeSetting <= 0)
        {
            player->volume = 0;
        }
        else if (volumeSetting >= 13)
        {
            player->volume = UINT14_MAX;
        }
        else
        {
            player->volume = (1 << (volumeSetting - 1));
        }
    }
}

void globalMidiPlayerPauseAll(void)
{
    if (globalPlayers)
    {
        for (int i = 0; i < NUM_GLOBAL_PLAYERS; i++)
        {
            midiPause(&globalPlayers[i], true);
        }
    }
}

void globalMidiPlayerResumeAll(void)
{
    if (globalPlayers)
    {
        for (int i = 0; i < NUM_GLOBAL_PLAYERS; i++)
        {
            midiPause(&globalPlayers[i], false);
        }
    }
}

void globalMidiPlayerStop(bool reset)
{
    if (globalPlayers)
    {
        for (int i = 0; i < NUM_GLOBAL_PLAYERS; i++)
        {
            midiPause(&globalPlayers[i], true);

            if (reset)
            {
                midiPlayerReset(&globalPlayers[i]);
            }
            // TODO: implement seek
            // midiSeek(&globalPlayers[i], 0);
        }
    }
}

midiPlayer_t* globalMidiPlayerGet(uint8_t songIdx)
{
    if (globalPlayers)
    {
        return &globalPlayers[songIdx];
    }
    return NULL;
}
