#include "midiPlayer.h"

#include <string.h>
#include <inttypes.h>

#include "waveTables.h"
#include "midiNoteFreqs.h"
#include "midiUtil.h"
#include "hdw-dac.h"
#include "fp_math.h"
#include "esp_log.h"
#include "drums.h"
#include "macros.h"

#define OSC_DITHER

//==============================================================================
// Generated by tools/midi/freqs.py
//==============================================================================
#ifdef OSC_DITHER
// Apply a random offset to each oscillator to maybe make it less likely for waves to "stack" exactly
static const uint8_t oscDither[] = {
    139, 227, 5,   103, 241, 67, 251, 109, 197, 59,  61,  3,   53,  229, 127, 23,  73,  223,
    13,  19,  47,  7,   181, 37, 2,   239, 29,  113, 167, 131, 41,  151, 83,  137, 11,  193,
    107, 17,  191, 43,  101, 71, 233, 179, 97,  79,  31,  211, 163, 157, 89,  199, 149, 173,
};
#endif
//==============================================================================
// End generated code section
//==============================================================================

// For MIDI values with coarse and fine bytes, each 7 bits
#define UINT14_MAX (0x3FFF)

/// @brief Convert the sample count to MIDI ticks
#define SAMPLES_TO_MIDI_TICKS(n, tempo, div) ((n) * 1000000 * (div) / DAC_SAMPLE_RATE_HZ / (tempo))

/// @brief Calculate the number of DAC samples in the given number of milliseconds
#define MS_TO_TICKS(ms) ((ms) * DAC_SAMPLE_RATE_HZ / 1000)

#define VS_ANY(statePtr) ((statePtr)->on)

// Values for the percussion special states bitmap
#define SHIFT_HI_HAT   (0)
#define SHIFT_WHISTLE  (6)
#define SHIFT_GUIRO    (12)
#define SHIFT_CUICA    (18)
#define SHIFT_TRIANGLE (24)

#define MASK_HI_HAT   (0x3F)
#define MASK_WHISTLE  (0x3F << SHIFT_WHISTLE)
#define MASK_GUIRO    (0x3F << SHIFT_GUIRO)
#define MASK_CUICA    (0x3F << SHIFT_CUICA)
#define MASK_TRIANGLE (0x3F << SHIFT_TRIANGLE)

// Represents that no voice has been allocated to the instrument, within the special states bitmap
#define VOICE_FREE (0x3F)

static bool globalPlayerInit                          = false;
static midiPlayer_t globalPlayers[NUM_GLOBAL_PLAYERS] = {0};

static uint32_t allocVoice(const voiceStates_t* states, uint8_t voiceCount);
static void setVoiceTimbre(midiVoice_t* voice, midiTimbre_t* timbre);
static void midiGmOn(midiPlayer_t* player);
static int32_t midiSumPercussion(midiPlayer_t* player);
static void handleMidiEvent(midiPlayer_t* player, const midiStatusEvent_t* event);
static void handleSysexEvent(midiPlayer_t* player, const midiSysexEvent_t* sysex);
static void handleMetaEvent(midiPlayer_t* player, const midiMetaEvent_t* event);
static void handleEvent(midiPlayer_t* player, const midiEvent_t* event);

static const midiTimbre_t defaultDrumkitTimbre = {
    .type = NOISE,
    .flags = TF_PERCUSSION,
    .percussion = {
        .playFunc = defaultDrumkitFunc,
        // TODO: Define the data and put it here!
        .data = NULL,
    },
    .envelope = { 0 },
    .name = "Swadge Drums 0",
};

static const midiTimbre_t acousticGrandPianoTimbre = {
    .type = WAVETABLE,
    .flags = TF_NONE,
    .waveIndex = 0,
    .envelope = {
        // TODO: Just realized I forgot how ADSR actually works halfway through writing everything else...
        // So go make sure the rest of everything makes sense, maybe rename everything to {a,d,r}Time and {s}Level for clarity
        // Pretty fast attack
        .attack = MS_TO_TICKS(24),
        // Take a good long while to reach the sustain level
        .decay = MS_TO_TICKS(750),
        // Sustain at about 75% of initial volume
        .sustain = 192,
        // And a not-too-short release time
        .release = MS_TO_TICKS(100),
        // Yup, I'm sure it will sound exactly like a grand piano now!
    },
    .name = "Acoustic Grand Piano",
};

// Check for the first unused note, then try to steal one in order of less to more bad, and return INT32_MAX if none are
// available
/**
 * @brief Return the index of an unallocated voice from the given voice pool.
 *
 * This function finds the voice index to allocate, but the caller is responsible for updating the state
 * bitmaps to actuallymark it as allocated.
 * If there are no unallocated voices remaining, an allocated voice index may be returned.
 *
 * @param states A pointer to the voice state bitmaps for this pool
 * @param voiceCount The number of voices in this pool
 * @return uint32_t The index of the voice to allocate
 */
static uint32_t allocVoice(const voiceStates_t* states, uint8_t voiceCount)
{
    uint32_t allStates
        = VS_ANY(states)
          | states->held; // states->attack | states->decay | states->release | states->sustain | states->held;

    // Set up a bitflag which has a 1 set for every voice that is NOT being used
    //                         /- flip the bits so a 1 represents an unused voice and a 0 represents an in-use voice
    //                        /                /- mask the bits to only go up to the number of voices we have
    //                       v                v
    uint32_t unusedVoices = (~allStates) & (0xFFFFFFFFu >> (32 - voiceCount));

    if (unusedVoices != 0)
    {
        // Return whatever the first voice that's not allocated is
        return __builtin_ctz(unusedVoices);
    }
    else
    {
        // Gotta steal a note, so steal the first one
        // TODO: This could be done more intelligently, but we have plenty of voices
        return 0;
    }
}

/**
 * @brief Set the timbre (instrument definition) of a MIDI voice
 *
 * @param voice The voice to set the timbre for
 * @param timbre A pointer to the MIDI timbre
 */
static void setVoiceTimbre(midiVoice_t* voice, midiTimbre_t* timbre)
{
    voice->timbre = timbre;
    for (uint8_t oscIdx = 0; oscIdx < OSC_PER_VOICE; oscIdx++)
    {
        switch (timbre->type)
        {
            case WAVETABLE:
            {
                swSynthSetWaveFunc(&voice->oscillators[oscIdx], waveTableFunc, (void*)((uintptr_t)timbre->waveIndex));
                break;
            }

            case NOISE:
            {
                swSynthSetShape(&voice->oscillators[oscIdx], SHAPE_NOISE);
                break;
            }

            case SAMPLE:
            {
                // TODO: Sample support!
                break;
            }
        }
    }
}

/**
 * @brief Activate General MIDI mode for a MIDI player
 *
 * @param player The MIDI player to set to General MIDI mode
 */
static void midiGmOn(midiPlayer_t* player)
{
    for (int voiceIdx = 0; voiceIdx < POOL_VOICE_COUNT + PERCUSSION_VOICES; voiceIdx++)
    {
        bool percussion = voiceIdx >= POOL_VOICE_COUNT;
        midiVoice_t* voice
            = percussion ? (&player->percVoices[voiceIdx - POOL_VOICE_COUNT]) : (&player->poolVoices[voiceIdx]);
        for (uint8_t oscIdx = 0; oscIdx < OSC_PER_VOICE; oscIdx++)
        {
            swSynthInitOscillatorWave(&voice->oscillators[oscIdx], waveTableFunc, (void*)((uint32_t)0), 0, 0);
#ifdef OSC_DITHER
            voice->oscillators[oscIdx].accumulator.bytes[3]
                = (oscDither[player->oscillatorCount % ARRAY_SIZE(oscDither)]) & 0xFF;
#endif
            player->allOscillators[player->oscillatorCount++] = &voice->oscillators[oscIdx];
        }

        voice->timbre = percussion ? &defaultDrumkitTimbre : &acousticGrandPianoTimbre;
    }

    for (uint8_t chanIdx = 0; chanIdx < MIDI_CHANNEL_COUNT; chanIdx++)
    {
        midiChannel_t* chan = &player->channels[chanIdx];

        chan->volume    = UINT14_MAX;
        chan->pitchBend = 0x2000;
        chan->program   = 0;

        if (chanIdx == 9)
        {
            // Channel 10 is reserved for percussion.
            chan->percussion = true;

            // TODO: Should we just have a pointer instead? That will work great as long as we don't need to modify the
            // timbre in-place (which MIDI does technically allow)
            memcpy(&chan->timbre, &defaultDrumkitTimbre, sizeof(midiTimbre_t));
        }
        else
        {
            chan->percussion = false;
            memcpy(&chan->timbre, &acousticGrandPianoTimbre, sizeof(midiTimbre_t));
        }
    }
}

/**
 * @brief Step each playing percussion note forward by one sample and return the raw sum
 *
 * @param player The MIDI player to sum percussion notes for
 * @return int32_t The unsigned 32-bit sample, without any headroom or clipping applied
 */
static int32_t midiSumPercussion(midiPlayer_t* player)
{
    voiceStates_t* states = &player->percVoiceStates;
    midiVoice_t* voices   = player->percVoices;

    int32_t sum = 0;

    // Ignore the 'held' flag, this is percussion!
    uint32_t playingVoices = states->on;
    while (playingVoices != 0)
    {
        uint8_t voiceIdx = __builtin_ctz(playingVoices);
        playingVoices &= ~(1 << voiceIdx);

        bool done = false;
        sum += voices[voiceIdx].timbre->percussion.playFunc(voices[voiceIdx].note, voices[voiceIdx].sampleTick++, &done,
                                                            voices[voiceIdx].percScratch,
                                                            voices[voiceIdx].timbre->percussion.data);

        if (done)
        {
            switch (voices[voiceIdx].note)
            {
                case CLOSED_HI_HAT:
                case PEDAL_HI_HAT:
                case OPEN_HI_HAT:
                {
                    player->percSpecialStates |= VOICE_FREE << SHIFT_HI_HAT;
                    break;
                }

                case SHORT_WHISTLE:
                case LONG_WHISTLE:
                {
                    player->percSpecialStates |= VOICE_FREE << SHIFT_WHISTLE;
                    break;
                }

                case SHORT_GUIRO:
                case LONG_GUIRO:
                {
                    player->percSpecialStates |= VOICE_FREE << SHIFT_GUIRO;
                    break;
                }

                case MUTE_CUICA:
                case OPEN_CUICA:
                {
                    player->percSpecialStates |= VOICE_FREE << SHIFT_CUICA;
                    break;
                }

                case MUTE_TRIANGLE:
                case OPEN_TRIANGLE:
                {
                    player->percSpecialStates |= VOICE_FREE << SHIFT_TRIANGLE;
                    break;
                }

                default:
                    break;
            }

            states->on &= ~(1 << voiceIdx);
            voices[voiceIdx].sampleTick = 0;
            memset(voices[voiceIdx].percScratch, 0, 4 * sizeof(uint32_t));
        }
    }

    return sum;
}

/**
 * @brief Process a normal MIDI status event and update the player state accordingly
 *
 * @param player The MIDI player to handle the event
 * @param event The MIDI status event to handle
 */
static void handleMidiEvent(midiPlayer_t* player, const midiStatusEvent_t* event)
{
    if (event->status & 0x80)
    {
        // Normal status message
        uint8_t channel = event->status & 0x0F;
        uint8_t cmd     = (event->status >> 4) & 0x0F;

        switch (cmd)
        {
            // Note OFF
            case 0x8:
            {
                uint8_t midiKey  = event->data[0];
                uint8_t velocity = event->data[1];
                midiNoteOff(player, channel, midiKey, velocity);
                break;
            }

            // Note ON
            case 0x9:
            {
                uint8_t midiKey  = event->data[0];
                uint8_t velocity = event->data[1];
                midiNoteOn(player, channel, midiKey, velocity);
                break;
            }

            // AfterTouch
            case 0xA:
                break;

            // Control change
            case 0xB:
            {
                uint8_t controlId  = event->data[0];
                uint8_t controlVal = event->data[1];
                switch (controlId)
                {
                    // Sustain
                    case 0x40:
                    {
                        midiSustain(player, channel, controlVal);
                        break;
                    }

                    // All sounds off (120)
                    case 0x78:
                    {
                        midiAllSoundOff(player);
                        break;
                    }

                    // All notes off (123)
                    case 0x7B:
                    {
                        midiAllNotesOff(player, channel);
                        break;
                    }

                    default:
                        break;
                }

                break;
            }

            // Program Select
            case 0xC:
            {
                uint8_t program = event->data[0];
                midiSetProgram(player, channel, program);
                break;
            }

            // Channel Pressure
            case 0xD:
                break;

            // Pitch bend
            case 0xE:
            {
                uint16_t range = ((event->data[1] & 0x7F) << 7) | (event->data[0] & 0x7F);
                midiPitchWheel(player, channel, range);
                break;
            }

            default:
                break;
        }
    }
    else if (event->status & 0xF0)
    {
        // System Message
    }
}

/**
 * @brief Process a non-MIDI meta-event from a file and update the player state accordingly
 *
 * @param player The MIDI player to handle the event
 * @param event The non-MIDI meta-event to handle
 */
static void handleMetaEvent(midiPlayer_t* player, const midiMetaEvent_t* event)
{
    switch (event->type)
    {
        case SEQUENCE_NUMBER:
            break;

        // Text events
        case TEXT:
        case COPYRIGHT:
        case SEQUENCE_OR_TRACK_NAME:
        case INSTRUMENT_NAME:
        case LYRIC:
        case MARKER:
        case CUE_POINT:
        {
            // Handle text, if the callback is set
            if (player->textMessageCallback)
            {
                player->textMessageCallback(event->type, event->text, event->length);
            }
            break;
        }

        // Obsolete
        case CHANNEL_PREFIX:
            break;
        case PORT_PREFIX:
            break;

        case END_OF_TRACK:
        {
            // TODO: Maybe detect if a track ends without including END_OF_TRACK and
            // synthesize one from the parser, just in case a file is malformed?
            if (player->reader.file->format == MIDI_FORMAT_2)
            {
                player->sampleCount = 0;
            }
            break;
        }

        case TEMPO:
        {
            midiSetTempo(player, event->tempo);
            break;
        }

        case SMPTE_OFFSET:
        {
            // TODO: Tempo support?
            break;
        }

        // These are informational only, we won't do anything with them here.
        case TIME_SIGNATURE:
            break;
        case KEY_SIGNATURE:
            break;

        // None supported
        case PROPRIETARY:
            break;
    }
}

/**
 * @brief Process a MIDI System-Exclusive event and update the player state accordingly
 *
 * @warning Not yet implemented
 *
 * @param player The MIDI player to handle the event
 * @param event The MIDI SysEx event to handle
 */
static void handleSysexEvent(midiPlayer_t* player, const midiSysexEvent_t* sysex)
{
    // TODO: Support SysEx commands - find some RGB ones we can yoink
    // Actually we can assign a non-registered control to R, G, and B
    // I think there's enough for every LED too assuming there's still like, 7 or so
    // AND: if possible have a sysex command (hmm) that sets all the LEDs to individual values at once
}

/**
 * @brief Process MIDI event of any type and update the player state accordingly
 *
 * @param player The MIDI player to handle the event
 * @param event The MIDI event to handle
 */
static void handleEvent(midiPlayer_t* player, const midiEvent_t* event)
{
    switch (event->type)
    {
        case MIDI_EVENT:
        {
            handleMidiEvent(player, &event->midi);
            break;
        }

        case META_EVENT:
        {
            handleMetaEvent(player, &event->meta);
            break;
        }

        case SYSEX_EVENT:
        {
            handleSysexEvent(player, &event->sysex);
            break;
        }
    }
}

void midiPlayerInit(midiPlayer_t* player)
{
    // Zero out EVERYTHING
    memset(player, 0, sizeof(midiPlayer_t));

    // Set up the values which must be non-zero
    midiPlayerReset(player);

    // Initialize all the instruments
    midiGmOn(player);
}

void midiPlayerReset(midiPlayer_t* player)
{
    midiAllSoundOff(player);

    // We need the tempo to not be zero, so set it to the default of 120BPM until we get a tempo event
    // 120 BPM == 500,000 microseconds per quarter note
    player->tempo = 500000;

    // Set all the relevant bits to 1, meaning not in use
    player->percSpecialStates = 0b00111111111111111111111111111111; // 0x4fffffff

    player->sampleCount    = 0;
    player->clipped        = 0;
    player->eventAvailable = false;
    player->volume         = UINT14_MAX;
    player->headroom       = MIDI_DEF_HEADROOM;

    deinitMidiParser(&player->reader);
    player->paused = true;
}

int32_t midiPlayerStep(midiPlayer_t* player)
{
    if (player->paused)
    {
        return 0;
    }

    bool checkEvents = false;
    if (player->mode == MIDI_FILE)
    {
        if (!player->eventAvailable)
        {
            player->eventAvailable = midiNextEvent(&player->reader, &player->pendingEvent);
        }

        if (player->eventAvailable)
        {
            if (player->pendingEvent.absTime
                <= SAMPLES_TO_MIDI_TICKS(player->sampleCount, player->tempo, player->reader.division))
            {
                checkEvents = true;
            }
        }
        else
        {
            ESP_LOGI("MIDI", "Done playing file!");
            for (uint8_t ch = 0; ch < MIDI_CHANNEL_COUNT; ch++)
            {
                midiAllNotesOff(player, 0);
            }

            if (player->songFinishedCallback)
            {
                player->songFinishedCallback();
            }

            if (player->loop && player->mode == MIDI_FILE && player->reader.file)
            {
                resetMidiParser(&player->reader);
                player->sampleCount = 0;
            }
            else
            {
                player->mode = MIDI_STREAMING;
            }
        }

        // Use a while loop since we may need to handle multiple events at the exact same time
        while (checkEvents
               && player->pendingEvent.absTime
                      <= SAMPLES_TO_MIDI_TICKS(player->sampleCount, player->tempo, player->reader.division))
        {
            // It's time, so handle the event now
            handleEvent(player, &player->pendingEvent);

            // Try and grab the next event, and if we got one, keep checking
            player->eventAvailable = midiNextEvent(&player->reader, &player->pendingEvent);
            checkEvents            = player->eventAvailable;
        }
    }
    else if (player->mode == MIDI_STREAMING)
    {
        if (player->streamingCallback)
        {
            while (player->streamingCallback(&player->pendingEvent))
            {
                handleEvent(player, &player->pendingEvent);
            }
        }
    }

    // TODO: Sample support
    // sample += samplerSumSamplers(player->allSamplers, player->samplerCount)
    int32_t sample = swSynthSumOscillators(player->allOscillators, player->oscillatorCount);
    sample += midiSumPercussion(player);

    player->sampleCount++;

    // Apply the global volume value
    sample *= player->volume;
    sample /= UINT14_MAX;

    return sample;
}

void midiPlayerFillBuffer(midiPlayer_t* player, uint8_t* samples, int16_t len)
{
    for (int16_t n = 0; n < len; n++)
    {
        // Step the state forward by one sample and return the next sample sum
        int32_t sample = midiPlayerStep(player);

        // Multiply the sample by 0.3 to provide some headroom for stacking samples
        sample *= player->headroom;
        sample >>= 16;

        if (sample < -128)
        {
            samples[n] = 0;
            player->clipped++;
        }
        else if (sample > 127)
        {
            samples[n] = 255;
            player->clipped++;
        }
        else
        {
            samples[n] = sample + 128;
        }
    }
}

void midiPlayerFillBufferMulti(midiPlayer_t* players, uint8_t playerCount, uint8_t* samples, int16_t len)
{
    for (int16_t n = 0; n < len; n++)
    {
        int32_t sample = 0;
        for (int i = 0; i < playerCount; i++)
        {
            // Apply the player's headroom to its sample sum
            sample += (midiPlayerStep(&players[i]) * players[i].headroom);
        }

        // Shift right by 16 to account for the headroom application
        sample >>= 16;

        // TODO: Can't keep track of clipping here... does it matter?
        if (sample < -128)
        {
            samples[n] = 0;
        }
        else if (sample > 127)
        {
            samples[n] = 255;
        }
        else
        {
            samples[n] = sample + 128;
        }
    }
}

void midiAllSoundOff(midiPlayer_t* player)
{
    // TODO: It is unclear whether this applies to every channel or just one
    // Seems like people "agree" it's special and applies to every channel
    // But also people say the spec is deficient in this area.
    // So if it's up to us, let's just do them all!

    for (uint8_t voiceIdx = 0; voiceIdx < POOL_VOICE_COUNT; voiceIdx++)
    {
        // Here we don't bother to check whether each voice is being used, since we want
        // to turn them off no matter what. This is because All Sounds Off is often used
        // as a "panic" button to stop any stuck notes. So, just in case we get in a bad
        // state where notes are playing but we don't "think" they are, this will always
        // stop them anyway.
        // TODO: Maybe move this all into a stopVoice() function
        player->poolVoices[voiceIdx].transitionTicks = 0;
        player->poolVoices[voiceIdx].targetVol       = 0;
        player->poolVoiceStates.held                 = 0;
        player->poolVoiceStates.on                   = 0;
        // TODO: Handle samplers
        for (uint8_t oscIdx = 0; oscIdx < OSC_PER_VOICE; oscIdx++)
        {
            swSynthSetVolume(&player->poolVoices[voiceIdx].oscillators[oscIdx], 0);
            swSynthSetFreqPrecise(&player->poolVoices[voiceIdx].oscillators[oscIdx], 0);
        }
    }

    for (uint8_t voiceIdx = 0; voiceIdx < PERCUSSION_VOICES; voiceIdx++)
    {
        player->percVoices[voiceIdx].transitionTicks = 0;
        player->percVoices[voiceIdx].targetVol       = 0;
        player->percVoiceStates.held                 = 0;
        player->percVoiceStates.on                   = 0;
        for (uint8_t oscIdx = 0; oscIdx < OSC_PER_VOICE; oscIdx++)
        {
            player->percVoices[voiceIdx].targetVol = 0;
            swSynthSetVolume(&player->percVoices[voiceIdx].oscillators[oscIdx], 0);
            swSynthSetFreqPrecise(&player->percVoices[voiceIdx].oscillators[oscIdx], 0);
        }
    }

    for (int chanIdx = 0; chanIdx < MIDI_CHANNEL_COUNT; chanIdx++)
    {
        midiChannel_t* chan = &player->channels[chanIdx];
        chan->allocedVoices = 0;
        chan->held          = false;
    }
}

void midiAllNotesOff(midiPlayer_t* player, uint8_t channel)
{
    midiChannel_t* chan   = &player->channels[channel];
    voiceStates_t* states = chan->percussion ? &player->percVoiceStates : &player->poolVoiceStates;

    uint32_t playingVoices = VS_ANY(states) | states->held;
    while (playingVoices != 0)
    {
        // TODO / FIXME: This causes an additional search for the playing channel which is unnecessary
        // Instead, refactor the core of midiNoteOff() into an internal midiVoiceOff() function
        // That's probably a good idea anyway with how complicated midiNoteOff() is getting
        uint8_t voiceIdx = __builtin_ctz(playingVoices);
        midiNoteOff(player, channel, player->poolVoices[voiceIdx].note, 0x7F);

        playingVoices &= ~(1 << voiceIdx);
    }
}

void midiNoteOn(midiPlayer_t* player, uint8_t chanId, uint8_t note, uint8_t velocity)
{
    if (velocity == 0)
    {
        // MIDI note on with a value of 0 is considered a note off
        midiNoteOff(player, chanId, note, 0x7F);
        return;
    }

    midiChannel_t* chan = &player->channels[chanId];
    // Use the appropriate voice pool for the instrument type
    // Percussion gets its own
    voiceStates_t* states = chan->percussion ? &player->percVoiceStates : &player->poolVoiceStates;
    midiVoice_t* voices   = chan->percussion ? player->percVoices : player->poolVoices;
    uint8_t voiceCount    = chan->percussion ? PERCUSSION_VOICES : POOL_VOICE_COUNT;
    uint32_t voiceIdx     = allocVoice(states, voiceCount);

    if (chan->timbre.flags & TF_MONO)
    {
        if (chan->allocedVoices)
        {
            voiceIdx = chan->allocedVoices;
        }
    }

    if (chan->percussion)
    {
        // handle special cases for percussion instruments
        // this will check if a mutually exclusive note is already playing on a voice and cut it off with the new one
        switch (note)
        {
            case CLOSED_HI_HAT:
            case PEDAL_HI_HAT:
            case OPEN_HI_HAT:
            {
                uint8_t hiHatVoice = player->percSpecialStates & MASK_HI_HAT;
                if (hiHatVoice != VOICE_FREE)
                {
                    voiceIdx = hiHatVoice;
                }
                else
                {
                    player->percSpecialStates = (player->percSpecialStates & ~MASK_HI_HAT) | (voiceIdx << SHIFT_HI_HAT);
                }
                break;
            }

            case SHORT_WHISTLE:
            case LONG_WHISTLE:
            {
                uint8_t whistleVoice = (player->percSpecialStates & MASK_WHISTLE) >> SHIFT_WHISTLE;
                if (whistleVoice != VOICE_FREE)
                {
                    voiceIdx = whistleVoice;
                }
                else
                {
                    player->percSpecialStates
                        = (player->percSpecialStates & ~MASK_WHISTLE) | (voiceIdx << SHIFT_WHISTLE);
                }
                break;
            }

            case SHORT_GUIRO:
            case LONG_GUIRO:
            {
                uint8_t guiroVoice = (player->percSpecialStates & MASK_GUIRO) >> SHIFT_GUIRO;
                if (guiroVoice != VOICE_FREE)
                {
                    voiceIdx = guiroVoice;
                }
                else
                {
                    player->percSpecialStates = (player->percSpecialStates & ~MASK_GUIRO) | (voiceIdx << SHIFT_GUIRO);
                }
                break;
            }

            case MUTE_CUICA:
            case OPEN_CUICA:
            {
                uint8_t cuicaVoice = (player->percSpecialStates & MASK_CUICA) >> SHIFT_CUICA;
                if (cuicaVoice != VOICE_FREE)
                {
                    voiceIdx = cuicaVoice;
                }
                else
                {
                    player->percSpecialStates = (player->percSpecialStates & ~MASK_CUICA) | (voiceIdx << SHIFT_CUICA);
                }
                break;
            }

            case MUTE_TRIANGLE:
            case OPEN_TRIANGLE:
            {
                uint8_t triangleVoice = (player->percSpecialStates & MASK_TRIANGLE) >> SHIFT_TRIANGLE;
                if (triangleVoice != VOICE_FREE)
                {
                    voiceIdx = triangleVoice;
                }
                else
                {
                    player->percSpecialStates
                        = (player->percSpecialStates & ~MASK_TRIANGLE) | (voiceIdx << SHIFT_TRIANGLE);
                }
                break;
            }

            default:
                break;
        }

        // Handle the rest of the percussion notes normally, or handle the case where there was no conflict
    }

    if (voiceIdx >= voiceCount)
    {
        // no voices available and we couldn't find an appropriate one to steal
        // if this happens often we should just allocate more voices
        // (or make the stealing algorithm always succeed)
        return;
    }

    uint32_t voiceBit = (1 << voiceIdx);

    chan->allocedVoices |= voiceBit;
    states->on |= voiceBit;
    voices[voiceIdx].note = note;

    // TODO: Add a note -> voice map in the channel?
    uint8_t targetVol          = velocity << 1 | 1;
    voices[voiceIdx].targetVol = targetVol;

    if (chan->timbre.flags & TF_PERCUSSION)
    {
        // Reset the percussion voice state
        voices[voiceIdx].sampleTick = 0;
    }
    else
    {
        // Ensure the selected voice will play with the right instrument
        if (voices[voiceIdx].timbre != &chan->timbre)
        {
            setVoiceTimbre(&voices[voiceIdx], &chan->timbre);
        }

        swSynthSetVolume(&voices[voiceIdx].oscillators[0], targetVol);
        swSynthSetFreqPrecise(&voices[voiceIdx].oscillators[0], bendPitchWheel(note, chan->pitchBend));
    }
}

void midiNoteOff(midiPlayer_t* player, uint8_t channel, uint8_t note, uint8_t velocity)
{
    midiChannel_t* chan   = &player->channels[channel];
    voiceStates_t* states = chan->percussion ? &player->percVoiceStates : &player->poolVoiceStates;
    midiVoice_t* voices   = chan->percussion ? player->percVoices : player->poolVoices;

    // check the bitmaps to see if there's any note to release
    uint32_t playingVoices = VS_ANY(states) & chan->allocedVoices;

    // Find the channel playing this note
    while (playingVoices != 0)
    {
        uint8_t voiceIdx  = __builtin_ctz(playingVoices);
        uint32_t voiceBit = (1 << voiceIdx);

        if (voices[voiceIdx].note == note)
        {
            // This is the one we want!

            // Unset the on-ness of this note
            states->on &= ~voiceBit;
            chan->allocedVoices &= ~voiceBit;
            if (chan->held)
            {
                states->held |= voiceBit;
            }
            else
            {
                voices[voiceIdx].targetVol = 0;
                for (uint8_t i = 0; i < OSC_PER_VOICE; i++)
                {
                    swSynthSetVolume(&voices[voiceIdx].oscillators[i], 0);
                }
            }

            return;
        }

        // Move on to the next voice
        playingVoices &= ~voiceBit;
    }
}

void midiSetProgram(midiPlayer_t* player, uint8_t channel, uint8_t program)
{
    // Dynamic voice allocation somehow makes this way simpler
    player->channels[channel].program = program;
    // TODO: Actually define all the timbres individually instead of editing them like this
    // It's fine for now because envelopes, etc. aren't fully implemented so the only difference is the wave index
    player->channels[channel].timbre.waveIndex = program;
}

void midiSustain(midiPlayer_t* player, uint8_t channel, uint8_t val)
{
    midiChannel_t* chan = &player->channels[channel];
    bool newIsHold      = MIDI_TO_BOOL(val);

    if (chan->held != newIsHold)
    {
        voiceStates_t* voiceStates = chan->percussion ? &player->percVoiceStates : &player->poolVoiceStates;
        midiVoice_t* voices        = chan->percussion ? player->percVoices : player->poolVoices;
        if (newIsHold)
        {
            // Just set the held state for all the currently on notes.
            voiceStates->held |= voiceStates->on;
        }
        else
        {
            // for now what we do is just, if the note is held and not on, turn it off
            // if the note is on, just unset held
            // We should cancel all the notes which are not currently being held
            uint32_t notesToCancel = voiceStates->held & ~(voiceStates->on);

            // unset the hold flag for all
            // TODO: Isn't this going to always be 0?
            uint32_t newHold = (voiceStates->held & ~notesToCancel);

            while (notesToCancel != 0)
            {
                uint8_t voiceIdx  = __builtin_ctz(notesToCancel);
                uint32_t voiceBit = (1 << voiceIdx);

                // unset the note's bit and move on to the next one
                notesToCancel &= ~voiceBit;

                for (uint8_t i = 0; i < OSC_PER_VOICE; i++)
                {
                    swSynthSetVolume(&voices[voiceIdx].oscillators[i], 0);
                }
            }

            voiceStates->held = newHold;
        }
        chan->held = newIsHold;
    }
}

void midiControlChange(midiPlayer_t* player, uint8_t channel, uint8_t control, uint8_t val)
{
    // MIDI spec says control changes stop the channel
    // TODO: Implement some controls
    midiAllNotesOff(player, channel);
    // TODO maybe some sort of resetChannel() function?
}

void midiPitchWheel(midiPlayer_t* player, uint8_t channel, uint16_t value)
{
    // Save the pitch bend value
    player->channels[channel].pitchBend = value;
    voiceStates_t* states = player->channels[channel].percussion ? &player->percVoiceStates : &player->poolVoiceStates;
    midiVoice_t* voices   = player->channels[channel].percussion ? player->percVoices : player->poolVoices;

    // Find all the voices currently sounding for this channel and update their frequencies
    uint32_t playingVoices = (VS_ANY(states) | states->held) & player->channels[channel].allocedVoices;

    while (playingVoices != 0)
    {
        uint8_t voiceIdx  = __builtin_ctz(playingVoices);
        uint32_t voiceBit = (1 << voiceIdx);

        for (uint8_t oscIdx = 0; oscIdx < OSC_PER_VOICE; oscIdx++)
        {
            // Apply the pitch bend to all this channel's oscillators
            // TODO: If each voice has multiple oscillators, we would obviously
            // want to be able to control them separately here.
            // Maybe we only apply that for like, chorus?
            swSynthSetFreqPrecise(&voices[voiceIdx].oscillators[oscIdx], bendPitchWheel(voices[voiceIdx].note, value));
        }

        // Next!
        playingVoices &= ~voiceBit;
    }
}

void midiSetTempo(midiPlayer_t* player, uint32_t tempo)
{
    uint32_t oldTempo = player->tempo;

    player->tempo       = tempo;
    player->sampleCount = player->sampleCount * tempo / oldTempo;
}

void midiSetFile(midiPlayer_t* player, midiFile_t* song)
{
    player->mode = MIDI_FILE;
    if (player->reader.states == NULL)
    {
        initMidiParser(&player->reader, song);
    }
    else if (song == NULL)
    {
        deinitMidiParser(&player->reader);
        player->mode   = MIDI_STREAMING;
        player->paused = true;
    }
    else
    {
        midiParserSetFile(&player->reader, song);
    }
}

void midiPause(midiPlayer_t* player, bool pause)
{
    player->paused = pause;
}

//==============================================================================
// System-wide MIDI player functions
//==============================================================================

void initGlobalMidiPlayer(void)
{
    if (!globalPlayerInit)
    {
        globalPlayerInit = true;
        for (int i = 0; i < NUM_GLOBAL_PLAYERS; i++)
        {
            midiPlayerInit(&globalPlayers[i]);
        }
    }
}

void deinitGlobalMidiPlayer(void)
{
    if (globalPlayerInit)
    {
        for (int i = 0; i < NUM_GLOBAL_PLAYERS; i++)
        {
            midiPause(&globalPlayers[i], true);
            midiAllSoundOff(&globalPlayers[i]);
            midiPlayerReset(&globalPlayers[i]);
        }

        globalPlayerInit = false;
    }
}

void globalMidiPlayerFillBuffer(uint8_t* samples, int16_t len)
{
    if (globalPlayerInit)
    {
        midiPlayerFillBufferMulti(globalPlayers, NUM_GLOBAL_PLAYERS, samples, len);
    }
    else
    {
        memset(samples, 128, len);
    }
}

void globalMidiPlayerPlaySong(midiFile_t* song, uint8_t songIdx)
{
    initGlobalMidiPlayer();

    midiPause(&globalPlayers[songIdx], true);
    globalPlayers[songIdx].sampleCount = 0;
    midiSetFile(&globalPlayers[songIdx], song);
    midiPause(&globalPlayers[songIdx], false);
}

void globalMidiPlayerPlaySongCb(midiFile_t* song, uint8_t songIdx, songFinishedCbFn cb)
{
    globalMidiPlayerPlaySong(song, songIdx);
    globalPlayers[songIdx].songFinishedCallback = cb;
}

void globalMidiPlayerSetVolume(uint8_t trackType, int32_t volumeSetting)
{
    midiPlayer_t* player = &globalPlayers[trackType];

    if (volumeSetting <= 0)
    {
        player->volume = 0;
    }
    else if (volumeSetting >= 13)
    {
        player->volume = UINT14_MAX;
    }
    else
    {
        player->volume = (1 << (volumeSetting - 1));
    }
}

void globalMidiPlayerPauseAll(void)
{
    for (int i = 0; i < NUM_GLOBAL_PLAYERS; i++)
    {
        midiPause(&globalPlayers[i], true);
    }
}

void globalMidiPlayerResumeAll(void)
{
    for (int i = 0; i < NUM_GLOBAL_PLAYERS; i++)
    {
        midiPause(&globalPlayers[i], false);
    }
}

void globalMidiPlayerStop(bool reset)
{
    for (int i = 0; i < NUM_GLOBAL_PLAYERS; i++)
    {
        midiPause(&globalPlayers[i], true);

        if (reset)
        {
            midiPlayerReset(&globalPlayers[i]);
        }
        // TODO: implement seek
        // midiSeek(&globalPlayers[i], 0);
    }
}

midiPlayer_t* globalMidiPlayerGet(uint8_t songIdx)
{
    return &globalPlayers[songIdx];
}
